<!DOCTYPE html>
<html>
<head>
  <title>GTA1-like Game</title>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mapWidth = 30000;
const mapHeight = 30000;
const tileSize = 250; // Adjusted for zoom
const playerSize = 16;
const noiseScale = 0.02;
const noiseScale2 = 0.05;

canvas.width = 800; // Fixed viewport size
canvas.height = 600;

const simplex = new SimplexNoise();

const player = {
  x: 0,
  y: 0,
  speed: 2,
};

const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
};

document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
});

document.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});

// Textures
const textures = {
  water: new Image(),
  city: new Image(),
  suburbs: new Image(),
  grassland: new Image(),
  road: new Image(),
};

// Load textures
textures.water.src = 'water.png';
textures.city.src = 'city.png';
textures.suburbs.src = 'suburbs.png';
textures.grassland.src = 'grassland.png';
textures.road.src = 'road.png';

// Generate the map
function generateMap() {
  const mapData = [];
  for (let y = 0; y < mapHeight / tileSize; y+=0.25) {
    const row = [];
    for (let x = 0; x < mapWidth / tileSize; x+=0.25) {
      const noiseValue1 = simplex.noise2D(x * noiseScale, y * noiseScale);
      const noiseValue2 = simplex.noise2D(x * noiseScale2, y * noiseScale2) * 0.5;
      const combinedNoise = noiseValue1 + noiseValue2;

      let biome = 'grassland';
      if (combinedNoise < -0.5) {
        biome = 'water';
      } else if (combinedNoise < -0.1) {
        biome = 'suburbs';
      } else if (combinedNoise > 0.9) {
        biome = 'city';
      } else if (combinedNoise > 0.4) {
        biome = 'suburbs';
      }

      row.push({
        noise: combinedNoise,
        biome: biome,
      });
    }
    mapData.push(row);
  }

  // Set player to spawn in a city
  for (let y = 0; y < mapData.length; y++) {
    for (let x = 0; x < mapData[y].length; x++) {
      if (mapData[y][x].biome === 'city') {
        player.x = x * tileSize;
        player.y = y * tileSize;
        return mapData;
      }
    }
  }

  return mapData;
}

const map = generateMap();

// Road logic
function isCityRoad(x, y) {
  const cycle = 13;
  const xMod = x % cycle;
  const yMod = y % cycle;
  return (xMod < 2) || (yMod < 2);
}

function isSuburbRoad(x, y) {
  const mainCycle = 15;
  const branchCycle = 3;
  return (x % mainCycle === 0) || (y % branchCycle === 0);
}

// Draw the map
function drawMap() {
  const viewWidth = Math.ceil(canvas.width / tileSize);
  const viewHeight = Math.ceil(canvas.height / tileSize);

  // Calculate top-left corner of the visible map in tiles
  const offsetX = player.x - canvas.width / 2;
  const offsetY = player.y - canvas.height / 2;

  const startTileX = Math.floor(offsetX / tileSize);
  const startTileY = Math.floor(offsetY / tileSize);

  const tileOffsetX = offsetX % tileSize;
  const tileOffsetY = offsetY % tileSize;

  for (let y = 0; y <= viewHeight; y++) {
    for (let x = 0; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < mapWidth / tileSize && mapY >= 0 && mapY < mapHeight / tileSize) {
        const tile = map[mapY][mapX];
        const worldTileX = mapX;
        const worldTileY = mapY;

        let texture = textures[tile.biome] || textures.grassland;

        let isRoad = false;
        if (tile.biome === 'city') {
          isRoad = isCityRoad(worldTileX, worldTileY);
        } else if (tile.biome === 'suburbs') {
          isRoad = isSuburbRoad(worldTileX, worldTileY);
        }

        if (isRoad) {
          texture = textures.road;
        }

        ctx.drawImage(
          texture,
          x * tileSize - tileOffsetX,
          y * tileSize - tileOffsetY,
          tileSize,
          tileSize
        );
      }
    }
  }
}

// Game loop
function gameLoop() {
  // Player movement
  if (keys.ArrowUp) player.y -= player.speed;
  if (keys.ArrowDown) player.y += player.speed;
  if (keys.ArrowLeft) player.x -= player.speed;
  if (keys.ArrowRight) player.x += player.speed;

  // Keep player within bounds
  player.x = Math.max(0, Math.min(mapWidth - tileSize, player.x));
  player.y = Math.max(0, Math.min(mapHeight - tileSize, player.y));

  // Draw everything
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();

  // Draw player
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(
    canvas.width / 2 - playerSize / 2,
    canvas.height / 2 - playerSize / 2,
    playerSize,
    playerSize
  );

  requestAnimationFrame(gameLoop);
}

// Start the game loop after textures load
const allTextures = Object.values(textures);
Promise.all(allTextures.map((img) => new Promise((resolve) => (img.onload = resolve)))).then(() => {
  gameLoop();
});
</script>
</body>
</html>
