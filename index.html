<!DOCTYPE html>
<html>
<head>
  <title>UoE3 Game</title>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #phoneMenu {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      height: 500px;
      background: rgba(0,0,0,0.9);
      color: white;
      display: none;
      flex-direction: column;
      border-radius: 15px;
      padding: 15px;
      z-index: 1000;
      border: 1px solid #333;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    .menu-item { 
      padding: 10px;
      margin: 5px 0;
      background: #2d2d2d;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .menu-item:hover {
      background: #3d3d3d;
    }
    /* Chat Interface */
    
    #closePhoneMenu {
      color: #ff4444;
      font-size: 24px;
      cursor: pointer;
      padding: 0 10px;
    }

    #phoneMenuHeader {
      padding: 0;
      margin: 0 0 15px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

  #chatContainer {
    position: fixed;
    bottom: 80px;
    right: 20px;
    width: 350px;
    height: 500px;
    background: rgba(0,0,0,0.9);
    border-radius: 15px;
    display: none;
    flex-direction: column;
    color: white;
    border: 1px solid #333;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    z-index: 1000;
  }

  #chatHeader {
    padding: 15px;
    border-bottom: 1px solid #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  #closeChat {
    color: #ff4444;
    font-size: 24px;
    cursor: pointer;
    padding: 0 10px;
  }

  #chatMessages {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .message {
    max-width: 80%;
    padding: 10px 15px;
    border-radius: 15px;
    animation: messageAppear 0.3s ease;
  }

  .npc-message {
    background: #2d2d2d;
    align-self: flex-start;
  }

  .player-message {
    background: #0078d4;
    align-self: flex-end;
  }

  #chatInputContainer {
    padding: 15px;
    border-top: 1px solid #333;
  }

  #chatInput {
    width: 100%;
    padding: 10px;
    border-radius: 25px;
    border: none;
    background: #1e1e1e;
    color: white;
  }

  /* Phone Contacts */
  #phoneContacts {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 300px;
    height: 500px;
    background: rgba(0,0,0,0.9);
    display: none;
    flex-direction: column;
    border-radius: 15px;
    padding: 15px;
    z-index: 1001;
  }

  .contact {
    padding: 10px;
    margin: 5px 0;
    background: #2d2d2d;
    border-radius: 10px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .contact:hover {
    background: #3d3d3d;
  }

  @keyframes messageAppear {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
 
<div id="dialogueBox" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; max-width: 500px;">
  <div id="dialogueContent"></div>
  <div id="dialogueOptions" style="margin-top: 10px;"></div>
  <input type="text" id="playerInput" style="margin-top: 10px; width: 100%; display: none;">
  <button onclick="sendPlayerMessage()" style="margin-top: 5px; display: none;">Send</button>
</div>

<div id="phoneMenu">
  <div id="phoneMenuHeader">
    <h3 style="margin: 0;">Phone</h3>
    <div id="closePhoneMenu" onclick="togglePhoneMenu()">×</div>
  </div>
  <div class="menu-item" onclick="spawnCar('sedan')">Spawn Sedan</div>
  <div class="menu-item" onclick="spawnCar('sports')">Spawn Sports Car</div>
  <div class="menu-item" onclick="spawnCar('truck')">Spawn Truck</div>
  <div class="menu-item" onclick="showContacts()">Contacts</div>
</div>

<div id="chatContainer">
  <div id="chatHeader">
    <span id="chatTitle">Conversation</span>
    <div id="closeChat">×</div>
  </div>
  <div id="chatMessages"></div>
  <div id="chatInputContainer">
    <input type="text" id="chatInput" placeholder="Type your message...">
  </div>
</div>

<div id="phoneContacts">
  <div id="phoneContactsHeader">
    <h3 style="margin: 0;">Contacts</h3>
    <div id="closeContacts" onclick="toggleContacts()">×</div>
  </div>
  <div id="contactsList"></div>
</div>

<div id="miniMap" style="position: fixed; top: 20px; right: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.8); border: 2px solid #fff;">
  <canvas id="mapCanvas"></canvas>
</div>

<div id="fullMap" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999;">
  <canvas id="fullMapCanvas"></canvas>
  <div style="position: absolute; top: 20px; right: 20px; color: white; cursor: pointer;" onclick="toggleFullMap()">×</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { antialias: false });
const mapWidth = 100000;
const mapHeight = 100000;
const tileSize = 400; // Adjusted for zoom
const playerSize = 16;
const noiseScale = 0.005;
const noiseScale2 = 0.0125;
const DIRECTION = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
const cars = [];
const traffic = [];
const HOUSE_PROBABILITY = 0.3;
const CHUNK_SIZE = 1000; // World units
const loadedChunks = new Set();
const npcs = [];
let currentInteractingNPC = null;
const NPC_UPDATE_INTERVAL = 100;
const DIALOGUE_RANGE = 100; // Distance for conversation
const API_KEY = "Insert api key";
const FPS = 200;
let lastFrame = 0;
const TRAFFIC_UPDATE_INTERVAL = 50; // ms between traffic updates
let lastNPCUpdate = 0;
let lastTrafficUpdate = 0;


//console.log("API Key:", API_KEY);
  
const storyState = {
  cityMood: "calm",
  recentEvents: [],
  playerReputation: 0
};

canvas.width = 1920; // Fixed viewport size
canvas.height = 1080;

const simplex = new SimplexNoise();

const player = {
  x: 100,
  y: 100,
  speed: 2,
  visible: true,
  currentVehicle: null
};

const CORE_NPCS = [
  {
    name: "Mayor Evelyn Cross",
    role: "City Mayor",
    faction: "Government",
    personality: "Charismatic reformer pushing urban development",
    knowledge: ["City Budget", "Infrastructure Plans"],
    x: player.x + 500,  // Near starting position
    y: player.y + 500
  },
  {
    name: "Dr. Rajesh Verma",
    role: "Climate Scientist",
    faction: "University",
    personality: "Anxious researcher tracking ecological changes",
    knowledge: ["Climate Data", "Renewable Energy"],
    x: player.x - 500,
    y: player.y - 500
  }
];

const NPC_TEMPLATES = [
  // Government Faction
  {
    name: "Councilwoman Diane Hartman",
    role: "Urban Development Director",
    faction: "Government",
    personality: "Driven technocrat obsessed with modernization",
    knowledge: ["Zoning Laws", "Public Contracts"],
    keyValue: "Progress at any cost",
    secret: "Taking kickbacks from construction firms"
  },
  {
    name: "Agent Marcus Cole",
    role: "Public Safety Commissioner",
    faction: "Government",
    personality: "Paranoid former military strategist",
    knowledge: ["Surveillance Networks", "Gang Activity"],
    keyValue: "Order above all else",
    secret: "Maintains blacksite prison facilities"
  },

  // University Faction
  {
    name: "Dr. Elara Voss",
    role: "AI Ethics Professor",
    faction: "University",
    personality: "Idealistic but pragmatic philosopher",
    knowledge: ["Machine Learning", "Neuroethics"],
    keyValue: "Prevent technological dystopia",
    secret: "Developing unauthorized AI models"
  },
  {
    name: "Liam Chen",
    role: "Student Union Leader",
    faction: "University", 
    personality: "Charismatic activist with trust issues",
    knowledge: ["Protest Tactics", "University Finances"],
    keyValue: "Student power movement",
    secret: "Funding from anonymous donor"
  },

  // Press Faction
  {
    name: "Victoria Pryce",
    role: "Investigative Journalist",
    faction: "Press",
    personality: "Cynical truth-seeker with alcohol problem",
    knowledge: ["Political Scandals", "Corporate Espionage"],
    keyValue: "Destroy corrupt institutions",
    secret: "Being blackmailed by mayor's office"
  },
  {
    name: "Omar Khalid",
    role: "Tech Reporter",
    faction: "Press",
    personality: "Obsessive gadget enthusiast",
    knowledge: ["Emerging Tech", "Startup Culture"],
    keyValue: "Technological utopianism",
    secret: "Running illegal darknet review site"
  },

  // Public Works Faction
  {
    name: "Ingrid Bjornsson",
    role: "Waste Management Chief",
    faction: "Public Works",
    personality: "No-nonsense efficiency expert",
    knowledge: ["Recycling Systems", "Underground Tunnels"],
    keyValue: "Keep city functioning smoothly",
    secret: "Black market disposal service"
  },
  {
    name: "Dr. Kwame Nkosi",
    role: "Environmental Impact Officer",
    faction: "Public Works",
    personality: "Guilt-ridden former oil executive",
    knowledge: ["Pollution Data", "Green Tech"],
    keyValue: "Ecological redemption",
    secret: "Faking emission reports"
  },

  // Criminal Faction
  {
    name: "Nikolai 'The Tailor' Volkov",
    role: "Forgery Specialist",
    faction: "Criminal",
    personality: "Perfectionist with artistic temperament",
    knowledge: ["Document Systems", "Security Features"],
    keyValue: "Craftsmanship in illegality",
    secret: "Police informant"
  },
  {
    name: "Jiao Long",
    role: "Cybercrime Broker",
    faction: "Criminal",
    personality: "Paranoid digital anarchist",
    knowledge: ["Darknet Markets", "Encryption Systems"],
    keyValue: "Information wants to be free",
    secret: "Working on dead man's switch"
  },

  // Neutral/Cross-Faction
  {
    name: "Reverend Micah Blake",
    role: "Community Leader",
    faction: "Neutral",
    personality: "Empathetic mediator with dark past",
    knowledge: ["Gang Territories", "Social Programs"],
    keyValue: "Urban reconciliation",
    secret: "Former drug kingpin"
  },
  {
    name: "Kira 'Ghost' Nakamura",
    role: "Urban Explorer",
    faction: "Neutral",
    personality: "Adrenaline-junkie historian",
    knowledge: ["Abandoned Sites", "City Archives"],
    keyValue: "Preserve hidden history",
    secret: "Found doomsday bunker"
  },
  {
    name: "The Architect",
    role: "Mysterious Benefactor",
    faction: "Unknown",
    personality: "Cryptic master manipulator",
    knowledge: ["City Blueprints", "Secret Projects"],
    keyValue: "Social experimentation",
    secret: "AI controlling multiple identities"
  }
];

const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
  KeyW: false,
  KeyA: false,
  KeyS: false,
  KeyD: false,
  KeyF: false,
  KeyP: false,
  Enter: false
};


document.addEventListener('keydown', (e) => {

//  if(e.code === 'KeyE') handleInteractionKey();
  if(e.code === 'Enter' && currentInteractingNPC) sendPlayerMessage();
});


document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if(e.code === 'KeyP') {
    toggleMenu();
  }
  const enterRange = 50;
    const nearbyCar = [...cars, ...traffic].find(car => 
      !car.driver &&
      Math.abs(car.x - player.x) < enterRange &&
      Math.abs(car.y - player.y) < enterRange
    );
  if(e.code === 'KeyF' && nearbyCar) nearbyCar.enter(player);
  else if(e.code === 'KeyF' && player.currentVehicle) player.currentVehicle.exit();
  
  if(e.code === 'KeyE') handleInteractionKey();
  if(e.code === 'Enter' && currentInteractingNPC) sendPlayerMessage();
  if(e.code === 'KeyM')toggleFullMap();
});
document.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});




// Textures
const textures = {
  water: new Image(),
  suburbs: new Image(),
  grassland: new Image(),
  road_straight: new Image(),
  road_turn: new Image(),
  road_t: new Image(),
  road_x: new Image(),
  road_dead_end: new Image(),
  house: new Image(),
  school: new Image(),
  park: new Image(),
  cityback: new Image(),
  building3x3: new Image(),
  building2x2: new Image(),
  building2x1: new Image()
};

// Load textures
textures.water.src = 'water.png';
textures.suburbs.src = 'suburbs.png';
textures.grassland.src = 'grassland.png';
textures.road_straight.src = 'road_straight.png';
textures.road_turn.src = 'road_turn.png';
textures.road_t.src = 'road_t.png';
textures.road_x.src = 'road_x.png';
textures.road_dead_end.src = 'road_dead_end.png';
textures.house.src = 'house.png';
textures.school.src = 'school.png';
textures.park.src = 'park.png';
textures.building3x3.src = 'building2x2.png';
textures.building2x2.src = 'building3x3.png';
textures.building2x1.src = 'building2x1.png';
textures.cityback.src = 'citybackg.png';

const SCHOOL_PROBABILITY = 0.05;
const PARK_PROBABILITY = 0.2;
const LARGE_BUILDING_PROB = 0.5;
const MEDIUM_BUILDING_PROB = 1;
const SMALL_BUILDING_PROB = 1;


class Tile {
  constructor(biome, type = 'default', hasRoad = false) {
    this.biome = biome;
    this.type = type;
    this.hasRoad = hasRoad;
    this.rotation = 0;
    this.isStructureOrigin = false; // Add this property
    this.structureWidth = 1;
    this.structureHeight = 1;
    this.sidewalkNodes = [];
  }
  calculateSidewalkNodes(rotation) {
    const nodes = [];
    const offset = tileSize * 0.3; // Distance from road edge
    const center = tileSize/2;
    const quarter = tileSize/4;
    const eighth = tileSize/8;

    switch(this.roadType) {
      case 'straight':
        if(rotation % (Math.PI/2) === 0) { // Vertical
          this.sidewalkNodes.push(
            {x: center - offset, y: tileSize + 10},
            {x: center + offset, y: tileSize + 10}
          );
        } else { // Horizontal
          this.sidewalkNodes.push(
            {x: tileSize + 10, y: center - offset},
            {x: tileSize + 10, y: center + offset}
          );
        }
        break;

      case 'turn':
        // Circular path around the curve
        for(let angle = 0; angle < Math.PI/2; angle += Math.PI/12) {
          const x = center + Math.cos(angle + rotation) * (center - offset);
          const y = center + Math.sin(angle + rotation) * (center - offset);
          nodes.push({x, y});
          
          const x2 = center + Math.cos(angle + rotation) * (center + offset);
          const y2 = center + Math.sin(angle + rotation) * (center + offset);
          nodes.push({x: x2, y: y2});
        }
        break;

      case 't':
        // Three-way sidewalk connections
        nodes.push(
          {x: center - offset, y: 0},
          {x: center + offset, y: 0},
          {x: 0, y: center - offset},
          {x: 0, y: center + offset},
          {x: tileSize, y: center - offset},
          {x: tileSize, y: center + offset},
          {x: center - offset, y: tileSize},
          {x: center + offset, y: tileSize}
        );
        // Filter based on rotation
        this.sidewalkNodes = nodes.filter(n => {
          const angle = Math.atan2(n.y - center, n.x - center);
          return Math.abs(angle - rotation) < Math.PI/2 || 
                Math.abs(angle - rotation) > Math.PI*1.5;
        });
        break;

      case 'x': // Intersection
        nodes.push(
          {x: center - offset, y: 0},
          {x: center + offset, y: 0},
          {x: center - offset, y: tileSize},
          {x: center + offset, y: tileSize},
          {x: 0, y: center - offset},
          {x: 0, y: center + offset},
          {x: tileSize, y: center - offset},
          {x: tileSize, y: center + offset}
        );
        break;

      case 'dead_end':
        if(rotation === 0) { // Facing right
          nodes.push(
            {x: center - offset, y: center - offset},
            {x: center + offset, y: center - offset},
            {x: tileSize, y: center - offset},
            {x: tileSize, y: center + offset}
          );
        } else if(rotation === Math.PI) { // Facing left
          nodes.push(
            {x: center - offset, y: center - offset},
            {x: center + offset, y: center - offset},
            {x: 0, y: center - offset},
            {x: 0, y: center + offset}
          );
        } else if(rotation === Math.PI/2) { // Facing down
          nodes.push(
            {x: center - offset, y: center - offset},
            {x: center + offset, y: center - offset},
            {x: center - offset, y: tileSize},
            {x: center + offset, y: tileSize}
          );
        } else { // Facing up
          nodes.push(
            {x: center - offset, y: center - offset},
            {x: center + offset, y: center - offset},
            {x: center - offset, y: 0},
            {x: center + offset, y: 0}
          );
        }
        break;

      default:
        // Default to straight road behavior
        nodes.push(
          {x: center - offset, y: 0},
          {x: center + offset, y: 0},
          {x: center - offset, y: tileSize},
          {x: center + offset, y: tileSize}
        );
    }

    // Rotate points according to road orientation
    this.sidewalkNodes = nodes.map(n => {
      return {
        x: center + (n.x - center) * Math.cos(rotation) - (n.y - center) * Math.sin(rotation),
        y: center + (n.x - center) * Math.sin(rotation) + (n.y - center) * Math.cos(rotation)
      };
    });
  }
}
  
class ConversationManager {
  constructor() {
    this.currentNPC = null;
    this.isWaiting = false;
  }

  async start(npc) {
    this.currentNPC = npc;
    this.showDialogue(`<p><strong>${npc.name}:</strong> ${await this.getGreeting()}</p>`);
  }

  async getGreeting() {
    const response = await this.currentNPC.queryOpenAI(
      `Generate greeting from ${this.currentNPC.name} (${this.currentNPC.role})`
    );
    return response;
  }

  async sendMessage(message) {
    if(this.isWaiting) return;
    
    this.isWaiting = true;
    const response = await this.currentNPC.generateResponse(message);
    this.showResponse(response);
    this.isWaiting = false;
  }

  async end() {
    const worldUpdate = await this.currentNPC.generateWorldUpdate();
    this.applyWorldUpdate(worldUpdate);
    this.currentNPC = null;
  }

  // Add showDialogue, showResponse, applyWorldUpdate methods
}

class NPC {
  constructor(roleData) {
    this.x = roleData.x;
    this.y = roleData.y;
    this.name = roleData.name;
    this.role = roleData.role;
    this.faction = roleData.faction;
    this.personality = roleData.personality;
    this.knowledge = roleData.knowledge;
    this.conversationHistory = [];
    this.interactionCooldown = 0;
    this.speed = 1;
    this.destination = this.getRandomDestination();
    this.city = 0;//city;
    this.currentPath = [];
    this.isMoving = false;
    this.lastKnownPosition = { x: roleData.x, y: roleData.y };
    this.isInConversation = false;
    this.sidewalkPath = [];
    this.currentStep = 0;
  }



  async generateResponse(message) {
    // Add to conversation history
    this.conversationHistory.push(['player', message]);
    
    const response = await this.queryOpenAI(
      `Respond as ${this.name} to: "${message}". Keep it under 2 sentences.`
    );
    
    this.conversationHistory.push(['npc', response]);
    return response;
  }

  async updateBehavior() {
    if (Date.now() - this.lastAIUpdate > NPC_UPDATE_INTERVAL) {
      try {
        const prompt = `In a city that's currently ${storyState.cityMood}, ${this.name}, who is ${this.describePersonality()}, is currently ${this.currentAction}. Recent events: ${storyState.recentEvents.join(", ")}. What should they do next? Respond with ONLY a JSON object containing: {action: "string", destination: {x: number, y: number}, mood: "string"}`;
        
        const response = await this.queryOpenAI(prompt);
        const behavior = JSON.parse(response);
        
        this.currentAction = behavior.action;
        this.destination = behavior.destination;
        this.lastAIUpdate = Date.now();
        
        if(behavior.mood) {
          this.mood = behavior.mood;
        }
      } catch (error) {
        console.error("AI behavior error:", error);
      }
    }
  }

  describePersonality() {
    return `openness ${this.personality.openness.toFixed(2)}, conscientiousness ${this.personality.conscientiousness.toFixed(2)}, extraversion ${this.personality.extraversion.toFixed(2)}, agreeableness ${this.personality.agreeableness.toFixed(2)}, neuroticism ${this.personality.neuroticism.toFixed(2)}`;
  }

  async queryOpenAI(prompt) {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [{
          role: "user",
          content: prompt
        }],
        temperature: 0.7,
        max_tokens: 150
      })
    });

    const data = await response.json();
    return data.choices[0].message.content.trim();
  }

  generateNewPath() {
    // Get random nearby sidewalk path
    const startNode = roadNetwork.getNearestNode(this.x, this.y);
    if (startNode) {
      const endNode = roadNetwork.getRandomNode();
      const path = roadNetwork.getPath(startNode.x, startNode.y, endNode.x, endNode.y);
      if (path) {
        this.sidewalkPath = path.map(node => {
          const [x, y] = node.split('|').map(Number);
          return { x, y };
        });
        this.currentStep = 0;
      }
    }
  }


  isValidSidewalkPosition(x, y) {
    const tileX = Math.floor(x/tileSize);
    const tileY = Math.floor(y/tileSize);
    return tileY >= 0 && tileY < map.length && 
           tileX >= 0 && tileX < map[0].length &&
           map[tileY][tileX].sidewalkNodes?.some(n => 
             Math.abs(n.x - (x % tileSize)) < 10 && 
             Math.abs(n.y - (y % tileSize)) < 10
           );
  }

  getCurrentTile() {
    const tileX = Math.floor(this.x / tileSize);
    const tileY = Math.floor(this.y / tileSize);
    if(tileY >= 0 && tileY < map.length && tileX >= 0 && tileX < map[0].length) {
      return map[tileY][tileX];
    }
    return null;
  }
  getAdjacentTilesWithSidewalks() {
    const tileX = Math.floor(this.x / tileSize);
    const tileY = Math.floor(this.y / tileSize);
    const adjacent = [];
    
    for(let dx = -1; dx <= 1; dx++) {
      for(let dy = -1; dy <= 1; dy++) {
        if(tileY + dy >= 0 && tileY + dy < map.length && 
           tileX + dx >= 0 && tileX + dx < map[0].length) {
          const tile = map[tileY + dy][tileX + dx];
          if(tile?.sidewalkNodes?.length > 0) {
            adjacent.push(tile);
          }
        }
      }
    }
    return adjacent;
  }


  getRandomDestination() {
    return {
      x: this.x + (Math.random() - 0.5) * 500,
      y: this.y + (Math.random() - 0.5) * 500
    };
  }

  async generateDialogue(playerInput = null) {
    try {
      const prompt = this.createDialoguePrompt(playerInput);
      const response = await this.queryOpenAI(prompt);
      return this.processAIResponse(response);
    } catch (error) {
      console.error("Dialogue error:", error);
      return {text: "I can't talk right now.", options: []};
    }
  }

  createDialoguePrompt(playerInput) {
    return `In a ${storyState.cityMood} city, ${this.name} (${this.describePersonality()}) is talking to a player with reputation ${storyState.playerReputation}. 
    Previous conversation: ${this.conversationHistory.slice(-3).join(" | ")}
    ${playerInput ? `Player says: "${playerInput}"` : "Player initiates conversation"}
    Generate natural dialogue response and up to 3 options. Respond ONLY with JSON: {text: "string", options: ["string"], storyEffects: {}}`;
  }

  processAIResponse(response) {
    try {
      const data = JSON.parse(response);
      if(data.storyEffects) {
        Object.assign(storyState, data.storyEffects);
        if(data.storyEffects.recentEvents) {
          storyState.recentEvents.push(data.storyEffects.recentEvents);
          if(storyState.recentEvents.length > 5) storyState.recentEvents.shift();
        }
      }
      return data;
    } catch {
      return {text: response, options: []};
    }
  }
  async generateWorldUpdate() {
    const prompt = `Generate world changes based on conversation with ${this.name}. 
    Current state: ${storyState.cityMood}, Recent events: ${storyState.recentEvents.join(", ")}`;
    
    const update = await this.queryOpenAI(prompt);
    return JSON.parse(update);
  }
  canInteract() {
    return Date.now() > this.interactionCooldown && 
           !this.isInConversation &&
           Math.hypot(this.x - player.x, this.y - player.y) < DIALOGUE_RANGE;
  }
  
  draw(ctx, playerX, playerY) {
    const screenX = this.x - playerX + canvas.width/2;
    const screenY = this.y - playerY + canvas.height/2;
    
    if (Math.abs(screenX) < canvas.width * 1.5 && Math.abs(screenY) < canvas.height * 1.5) {
      // Draw NPC with walking animation
      ctx.fillStyle = '#00FF00';
      ctx.beginPath();
      ctx.arc(screenX, screenY - Math.abs(Math.sin(Date.now()*0.005)*5), 8, 0, Math.PI*2);
      ctx.fill();
      
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.fillText(this.name, screenX, screenY - 20);
    }
  }

  update() {
    if (this.isInConversation) return;

    if (this.sidewalkPath.length === 0 || this.currentStep >= this.sidewalkPath.length) {
      this.generateNewPath();
    }

    if (this.sidewalkPath.length > 0) {
      const target = this.sidewalkPath[this.currentStep];
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 2) {
        this.currentStep++;
      } else {
        // Move along path with proper sidewalk alignment
        const moveX = (dx / dist) * this.speed;
        const moveY = (dy / dist) * this.speed;
        
        // Snap to sidewalk grid
        this.x = Math.round(this.x + moveX);
        this.y = Math.round(this.y + moveY);
      }
    }
  }


}

class Car {
  constructor(x, y, type, color) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.color = color;

    // Vehicle performance characteristics
    switch(type) {
      case 'sports':
        this.maxSpeed = 4;
        this.acceleration = 0.01;
        this.minTurningRadius = 5;
        this.grip = 1.2;
        this.steeringResponse = 0.04;
        break;
      case 'truck':
        this.maxSpeed = 2;
        this.acceleration = 0.005;
        this.minTurningRadius = 7;
        this.grip = 2.0;
        this.steeringResponse = 0.04;
        break;
      default: // sedan
        this.maxSpeed = 3;
        this.acceleration = 0.0075;
        this.minTurningRadius = 6;
        this.grip = 1.6;
        this.steeringResponse = 0.03;
    }

    this.angle = 0;
    this.width = 30;
    this.height = 15;
    this.driver = null;
    this.active = false;
    this.isTraffic = false;
    this.currentSpeed = 0;
    this.deceleration = 0.002;
    this.wheelBase = 20; // Distance between front and rear axles
    this.track = this.width * 0.6; // Distance between left/right wheels
  }

  getCurrentTile() {
    // Add NaN checks and bounds protection
    const tileX = Math.floor(this.x / tileSize);
    const tileY = Math.floor(this.y / tileSize);
    
    // Validate coordinates
    if (isNaN(tileX) || isNaN(tileY)) {
      console.warn('Invalid vehicle position:', this.x, this.y);
      return { hasRoad: false };
    }

    // Check map bounds
    if (tileY < 0 || tileY >= map.length || tileX < 0 || tileX >= map[0].length) {
      return { hasRoad: false };
    }

    return map[tileY][tileX] || { hasRoad: false };
  }

  getCurrentRoadInfo() {
    const tileX = Math.floor(this.x / tileSize);
    const tileY = Math.floor(this.y / tileSize);
    
    // Add failsafe for invalid coordinates
    if (tileY < 0 || tileY >= map.length || tileX < 0 || tileX >= map[0].length) {
      return { type: 'grass', rotation: 0 };
    }

    return getRoadRotation(tileX, tileY);
  }

  handleOffRoad() {
    // Try to find nearest road or despawn
    if (Math.random() < 0.1) { // 10% chance per frame to recover
      const roadNode = roadNetwork.getNearestNode(this.x, this.y);
      if (roadNode) {
        this.x = roadNode.x;
        this.y = roadNode.y;
      }
    } else if (Math.random() < 0.01) { // 1% chance to despawn
      const index = traffic.indexOf(this);
      if (index > -1) traffic.splice(index, 1);
    }
  }

  alignWithRoad(roadInfo) {
    // Calculate target angle based on road type and rotation
    let targetAngle = roadInfo.rotation;
    if (roadInfo.type === 'straight') {
      targetAngle += (this.currentSpeed > 0 ? 0 : Math.PI);
    }
    
    // Smoothly adjust steering
    const angleDiff = targetAngle - this.angle;
    if (Math.abs(angleDiff) > 0.1) {
      this.angle += Math.sign(angleDiff) * this.steeringResponse * 
                   Math.min(1, this.currentSpeed/this.maxSpeed);
    }
  }

  approachingIntersection() {
    // Check if near intersection (T or X road)
    const tileX = Math.floor(this.x / tileSize);
    const tileY = Math.floor(this.y / tileSize);
    const roadInfo = getRoadRotation(tileX, tileY);
    return ['x', 't'].includes(roadInfo.type) && 
           Math.random() < 0.02; // Random chance to turn
  }

  handleIntersection(roadInfo) {
    // Get possible directions
    const directions = this.getPossibleDirections(roadInfo);
    
    // Randomly choose new direction
    if (directions.length > 0) {
      const newDirection = directions[Math.floor(Math.random() * directions.length)];
      this.angle = newDirection;
    }
  }

  getPossibleDirections(roadInfo) {
    const directions = [];
    const currentAngle = this.angle % (Math.PI * 2);
    
    switch(roadInfo.type) {
      case 'x':
        // Can go straight or turn
        directions.push(
          currentAngle,
          currentAngle + Math.PI/2,
          currentAngle - Math.PI/2
        );
        break;
      case 't':
        // Can't go back the way came
        const opposite = (currentAngle + Math.PI) % (Math.PI * 2);
        [0, Math.PI/2, -Math.PI/2].forEach(offset => {
          const dir = (currentAngle + offset) % (Math.PI * 2);
          if (Math.abs(dir - opposite) > Math.PI/4) {
            directions.push(dir);
          }
        });
        break;
    }
    return directions;
  }

  applyLaneDrift() {
    // Random lane drifting effect
    if (Math.random() < 0.01) {
      this.laneOffset = (Math.random() - 0.5) * this.track;
    }
    
    // Apply lane offset
    const laneAdjustX = Math.cos(this.angle + Math.PI/2) * this.laneOffset;
    const laneAdjustY = Math.sin(this.angle + Math.PI/2) * this.laneOffset;
    this.x += laneAdjustX;
    this.y += laneAdjustY;
  }

  updateTrafficBehavior() {
    const currentTile = this.getCurrentTile();
    if (!currentTile?.hasRoad) {
      this.handleOffRoad();
      return;
    }

    const roadInfo = this.getCurrentRoadInfo();
    
    // Accelerate to target speed
    this.currentSpeed = Math.min(
      this.currentSpeed + this.acceleration,
      this.maxSpeed
    );

    // Move along road direction
    this.x += Math.cos(roadInfo.rotation) * this.currentSpeed;
    this.y += Math.sin(roadInfo.rotation) * this.currentSpeed;

    // Lane keeping with smoother adjustment
    const laneOffset = 75;
    const roadCenterX = Math.floor(this.x/tileSize)*tileSize + tileSize/2;
    const roadCenterY = Math.floor(this.y/tileSize)*tileSize + tileSize/2;
    const targetX = roadCenterX + Math.cos(roadInfo.rotation + Math.PI/2) * laneOffset;
    const targetY = roadCenterY + Math.sin(roadInfo.rotation + Math.PI/2) * laneOffset;
    
    // Smooth lane adjustment
    this.x += (targetX - this.x) * 0.1;
    this.y += (targetY - this.y) * 0.1;
    
    // Update angle to match road direction
    this.angle = roadInfo.rotation;

    // Random speed variation
    this.currentSpeed *= (0.95 + Math.random() * 0.1);
  }
  handleIntersection(roadInfo) {
    if(Math.random() < 0.3) { // 30% chance to turn at intersection
      const directions = this.getPossibleDirections(roadInfo);
      if(directions.length > 0) {
        this.angle = directions[Math.floor(Math.random() * directions.length)];
        this.currentSpeed *= 0.8; // Slow down when turning
      }
    }
  }
  // Helper function for angle interpolation
  lerpAngle(current, target, factor) {
    const difference = target - current;
    return current + (Math.atan2(Math.sin(difference), Math.cos(difference)) * factor);
  }

  enter(player) {
    this.driver = player;
    this.active = true;
    player.visible = false;
    player.currentVehicle = this;
    this.currentSpeed = 0;
    this.x = player.x;
    this.y = player.y;
  }

  exit() {
    if (this.driver) {
      this.driver.x = this.x;
      this.driver.y = this.y;
      this.driver.visible = true;
      this.driver.currentVehicle = null;
      this.driver = null;
    }
    this.active = false;
  }

  draw(ctx, playerX, playerY) {
    const screenX = this.x - playerX + canvas.width/2 - this.width/2;
    const screenY = this.y - playerY + canvas.height/2 - this.height/2;
    
    ctx.save();
    ctx.translate(screenX + this.width/2, screenY + this.height/2);
    ctx.rotate(this.angle);
    ctx.fillStyle = this.color;
    
    // Draw car body
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    
    // Draw wheels
    ctx.fillStyle = '#333';
    const wheelWidth = 8;
    const wheelHeight = 4;
    const axleFront = this.wheelBase/2;
    const axleRear = -this.wheelBase/2;
    
    // Front wheels
    ctx.fillRect(-this.track/2, axleFront - wheelHeight/2, wheelWidth, wheelHeight);
    ctx.fillRect(this.track/2 - wheelWidth, axleFront - wheelHeight/2, wheelWidth, wheelHeight);
    
    // Rear wheels
    ctx.fillRect(-this.track/2, axleRear - wheelHeight/2, wheelWidth, wheelHeight);
    ctx.fillRect(this.track/2 - wheelWidth, axleRear - wheelHeight/2, wheelWidth, wheelHeight);
    
    ctx.restore();
  }

  update() {
    if (this.active && this.driver) {
      // Steering physics
      let steeringInput = 0;
      if (keys.KeyA || keys.ArrowLeft) steeringInput -= 1;
      if (keys.KeyD || keys.ArrowRight) steeringInput += 1;

      if (steeringInput !== 0 && this.currentSpeed !== 0) {
        const speed = Math.abs(this.currentSpeed);
        const maxTheoreticalSpeed = Math.sqrt(this.grip * this.minTurningRadius);
        let effectiveRadius;

        if (speed <= maxTheoreticalSpeed) {
          effectiveRadius = this.minTurningRadius;
        } else {
          effectiveRadius = (speed ** 2) / this.grip;
        }

        // Improved speed-sensitive steering
        const baseAngularVelocity = (this.currentSpeed / effectiveRadius) * steeringInput;
        const speedFactor = Math.min(1, speed / this.maxSpeed);
        const adjustedAngular = baseAngularVelocity * (1 - speedFactor * 0.7);
        
        this.angle += adjustedAngular * this.steeringResponse;
      }

      // Acceleration physics
      if (keys.KeyW || keys.ArrowUp) {
        this.currentSpeed = Math.min(
          this.currentSpeed + this.acceleration,
          this.maxSpeed
        );
      } else if (keys.KeyS || keys.ArrowDown) {
        this.currentSpeed = Math.max(
          this.currentSpeed - this.acceleration * 2,
          -this.maxSpeed * 0.5
        );
      } else {
        // Natural deceleration with rolling resistance
        const decel = this.currentSpeed > 0 ? 
          -this.deceleration * (1 + this.currentSpeed/this.maxSpeed) : 
          this.deceleration * (1 - this.currentSpeed/this.maxSpeed);
        this.currentSpeed += decel;
        if (Math.abs(this.currentSpeed) < 0.1) this.currentSpeed = 0;
      }
      
      // Apply movement with momentum
      const moveAngle = this.angle;
      this.x += Math.cos(moveAngle) * this.currentSpeed;
      this.y += Math.sin(moveAngle) * this.currentSpeed;
    } else if (this.isTraffic) {
      this.updateTrafficBehavior();
    }
  }
}

class RoadNetwork {
  constructor() {
    this.nodes = new Map();
    this.roadGraph = {};
  }

  addNode(x, y, connections) {
    const key = `${x}|${y}`;
    if(!this.roadGraph[key]) this.roadGraph[key] = [];
    connections.forEach(conn => {
      const connKey = `${conn.x}|${conn.y}`;
      if(!this.roadGraph[key].includes(connKey)) {
        this.roadGraph[key].push(connKey);
      }
    });
  }

  getPath(startX, startY, endX, endY) {
    const startKey = `${startX}|${startY}`;
    const endKey = `${endX}|${endY}`;
    
    const queue = [[startKey]];
    const visited = new Set();

    while(queue.length > 0) {
      const path = queue.shift();
      const node = path[path.length-1];

      if(node === endKey) return path;
      
      if(this.roadGraph[node]) {
        for(let neighbor of this.roadGraph[node]) {
          if(!visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push([...path, neighbor]);
          }
        }
      }
    }
    return null;
  }
  getNearestNode(x, y) {
    let closestNode = null;
    let minDistance = Infinity;

    for (const nodeKey of Object.keys(this.roadGraph)) {
      const [nodeX, nodeY] = nodeKey.split('|').map(Number);
      const distance = Math.hypot(x - nodeX, y - nodeY);
      
      if (distance < minDistance) {
        minDistance = distance;
        closestNode = { x: nodeX, y: nodeY };
      }
    }
    return closestNode;
  }

  getRandomNode() {
    const nodes = Object.keys(this.roadGraph);
    if (nodes.length === 0) return null;
    
    const randomKey = nodes[Math.floor(Math.random() * nodes.length)];
    const [x, y] = randomKey.split('|').map(Number);
    return { x, y };
  }
  getSidewalkPaths() {
    const paths = [];
    Object.keys(this.roadGraph).forEach(nodeKey => {
      const [x, y] = nodeKey.split('|').map(Number);
      const tile = map[Math.floor(y/tileSize)][Math.floor(x/tileSize)];
      if (tile?.sidewalkNodes?.length > 0) {
        paths.push(tile.sidewalkNodes.map(n => ({
          x: x + n.x - tileSize/2,
          y: y + n.y - tileSize/2
        })));
      }
    });
    return paths;
  }

  getNodeRotation(x, y) {
    const tileX = Math.floor(x / tileSize);
    const tileY = Math.floor(y / tileSize);
    return getRoadRotation(tileX, tileY).rotation;
  }
}

class ChatSystem {
  constructor() {
    this.knownNPCs = new Map();
    this.currentChat = null;
    
    // Event Listeners
    document.getElementById('closeChat').addEventListener('click', () => this.closeChat());
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if(e.key === 'Enter') this.sendMessage();
    });
    
    document.addEventListener('keydown', (e) => {
      if(e.key === 'Escape') this.closeChat();
      if(e.key === 'KeyP' && !this.currentChat) this.togglePhoneContacts();
    });
  }

  startChat(npc) {
    this.currentChat = npc;
    if(!this.knownNPCs.has(npc.name)) {
      this.knownNPCs.set(npc.name, npc);
      this.updateContacts();
    }
    
    document.getElementById('chatContainer').style.display = 'flex';
    document.getElementById('chatTitle').textContent = npc.name;
    this.loadHistory(npc);
  }

  async sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    if(!message) return;

    // Add player message
    this.addMessage(message, 'player');
    input.value = '';

    // Get NPC response
    const response = await this.currentChat.generateResponse(message);
    this.addMessage(response, 'npc');
  }

  addMessage(text, sender) {
    const messages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    messageDiv.textContent = text;
    messages.appendChild(messageDiv);
    messages.scrollTop = messages.scrollHeight;
  }

  loadHistory(npc) {
    const messages = document.getElementById('chatMessages');
    messages.innerHTML = '';
    npc.conversationHistory.forEach(([type, text]) => {
      this.addMessage(text, type === 'player' ? 'player' : 'npc');
    });
  }

  closeChat() {
    document.getElementById('chatContainer').style.display = 'none';
    this.currentChat = null;
  }

  togglePhoneContacts() {
    const contacts = document.getElementById('phoneContacts');
    contacts.style.display = contacts.style.display === 'none' ? 'flex' : 'none';
  }

  updateContacts() {
    const list = document.getElementById('contactsList');
    list.innerHTML = '';
    
    this.knownNPCs.forEach(npc => {
      const contact = document.createElement('div');
      contact.className = 'contact';
      contact.textContent = npc.name;
      contact.addEventListener('click', () => this.startPhoneChat(npc));
      list.appendChild(contact);
    });
  }

  startPhoneChat(npc) {
    this.togglePhoneContacts();
    this.startChat(npc);
  }
}

class PhoneSystem {
  constructor() {
    this.contacts = new Map();
    this.currentCall = null;
  }

  addContact(npc) {
    this.contacts.set(npc.id, {
      name: npc.name,
      number: this.generatePhoneNumber(),
      city: npc.city
    });
  }

  generatePhoneNumber() {
    return `555-${Math.floor(100 + Math.random() * 900)}-${Math.floor(1000 + Math.random() * 9000)}`;
  }

  startCall(npc) {
    this.currentCall = npc;
    npc.isInConversation = true;
    // Show chat interface
  }
}

class MapSystem {
  constructor() {
    this.mapCanvas = document.getElementById('mapCanvas');
    this.mapCtx = this.mapCanvas.getContext('2d');
    this.mapCanvas.width = 200;
    this.mapCanvas.height = 200;
  }

  draw() {
    this.mapCtx.fillStyle = 'rgba(0,0,0,0.8)';
    this.mapCtx.fillRect(0, 0, 200, 200);
    
    // Draw player position
    this.mapCtx.fillStyle = '#ff0000';
    this.mapCtx.beginPath();
    this.mapCtx.arc(100, 100, 3, 0, Math.PI * 2);
    this.mapCtx.fill();
    
    // Draw NPCs
    npcs.forEach(npc => {
      const dx = npc.x - player.x;
      const dy = npc.y - player.y;
      if(Math.abs(dx) < 2000 && Math.abs(dy) < 2000) {
        this.mapCtx.fillStyle = '#00ff00';
        this.mapCtx.beginPath();
        this.mapCtx.arc(100 + dx/20, 100 + dy/20, 2, 0, Math.PI * 2);
        this.mapCtx.fill();
      }
    });
  }
}

let interactionCooldown = false;

function handleInteractionKey() {
  if(!player.visible) return;


  if(currentInteractingNPC) {
    endConversation();
  } else {
    const nearestNPC = findNearestNPC();
    if(nearestNPC) startConversation(nearestNPC);
  }
}

function findNearestNPC() {
  let closest = null;
  let minDist = Infinity;

  npcs.forEach(npc => {
    const dx = npc.x - player.x;
    const dy = npc.y - player.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if(dist < DIALOGUE_RANGE && dist < minDist) {
      minDist = dist;
      closest = npc;
    }
  });

  return closest;
}

function showContacts() {
  document.getElementById('phoneMenu').style.display = 'none';
  document.getElementById('phoneContacts').style.display = 'flex';
}

function toggleFullMap() {
  const fullMap = document.getElementById('fullMap');
  fullMap.style.display = fullMap.style.display === 'none' ? 'block' : 'none';
  if(fullMap.style.display === 'block') {
    drawFullMap();
  }
}

function drawFullMap() {
  const fullCanvas = document.getElementById('fullMapCanvas');
  fullCanvas.width = window.innerWidth;
  fullCanvas.height = window.innerHeight;
  const ctx = fullCanvas.getContext('2d');
  
  // Draw the full map content
  ctx.fillStyle = 'rgba(0,0,0,0.9)';
  ctx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);
  
  // Draw player position
  ctx.fillStyle = '#ff0000';
  ctx.beginPath();
  ctx.arc(player.x / mapWidth * fullCanvas.width, 
          player.y / mapHeight * fullCanvas.height, 
          5, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw NPCs
  npcs.forEach(npc => {
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(npc.x / mapWidth * fullCanvas.width,
            npc.y / mapHeight * fullCanvas.height,
            3, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Generate the map
function generateMap() {
  const mapData = [];
  const centerX = mapWidth / 2;
  const centerY = mapHeight / 2;
  let closestTile = { x: centerX, y: centerY };
  let minDistance = Infinity;
  const largeStructures = new Set();

  // Initialize map with empty tiles
  for (let y = 0; y < mapHeight / tileSize; y++) {
    const row = [];
    for (let x = 0; x < mapWidth / tileSize; x++) {
      const noiseValue1 = simplex.noise2D(x * noiseScale, y * noiseScale);
      const noiseValue2 = simplex.noise2D(x * noiseScale2, y * noiseScale2) * 0.5;
      const combinedNoise = noiseValue1 + noiseValue2;

      let biome = 'grassland';
      if (combinedNoise < -0.5) biome = 'water';
      else if (combinedNoise < -0.1) biome = 'suburbs';
      else if (combinedNoise > 0.9) biome = 'city';
      else if (combinedNoise > 0.4) biome = 'suburbs';
      const currentTile = new Tile(biome)
      if(biome === 'city' && isCityRoad(x,y)){
        currentTile.hasRoad = true
      }
      if(biome === 'suburbs' && isSuburbRoad(x,y)){
        currentTile.hasRoad = true
      }
      row.push(currentTile);
    }
    mapData.push(row);
  }

  // Add structures
  for (let y = 0; y < mapHeight / tileSize; y++) {
    for (let x = 0; x < mapHeight / tileSize; x++) {
      const tile = mapData[y][x];
      const isCityRoadTile = isCityRoad(x, y);
      const isSuburbRoadTile = isSuburbRoad(x, y);
      tile.type = 'house';

      if (tile.biome === 'suburbs' && !isSuburbRoadTile && !largeStructures.has(`${x},${y}`) && !isRoadTileNoMap(x+1,y+1)) {
        if (Math.random() < SCHOOL_PROBABILITY && 
            x < mapData[0].length - 2 && y < mapData.length - 2) {
          for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
              const currentTile = mapData[y + dy][x + dx];
              currentTile.type = 'school';
              currentTile.structureWidth = 2;
              currentTile.structureHeight = 2;
              currentTile.isStructureOrigin = (dx === 0 && dy === 0);
              largeStructures.add(`${x + dx},${y + dy}`);
            }
          }
        }
        else if (Math.random() < PARK_PROBABILITY) {
          tile.type = 'park';
        }
        else{
          tile.type = 'house';
        }
      }
      else if (tile.biome === 'city' && !isCityRoadTile && !largeStructures.has(`${x},${y}`) && !largeStructures.has(`${x+2},${y}`)&&!largeStructures.has(`${x+2},${y+2}`) && !isRoadTileNoMap(x+2,y+2)&& !isRoadTileNoMap(x+1,y+1)) {
        if (Math.random() < LARGE_BUILDING_PROB && 
            x < mapData[0].length - 3 && y < mapData.length - 3) {
          for (let dx = 0; dx < 3; dx++) {
            for (let dy = 0; dy < 3; dy++) {
              const currentTile = mapData[y + dy][x + dx];
              currentTile.type = 'building3x3';
              currentTile.structureWidth = 3;
              currentTile.structureHeight = 3;
              currentTile.isStructureOrigin = (dx === 0 && dy === 0);
              largeStructures.add(`${x + dx},${y + dy}`);
            }
          }
        }
        else if (Math.random() < MEDIUM_BUILDING_PROB && 
              !isRoadTileNoMap(x,y)) { // x < mapData[0].length - 2 && y < mapData.length - 2 && 
          for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
              const currentTile = mapData[y + dy][x + dx];
              currentTile.type = 'building2x2';
              currentTile.structureWidth = 2;
              currentTile.structureHeight = 2;
              currentTile.isStructureOrigin = (dx === 0 && dy === 0);
              largeStructures.add(`${x + dx},${y + dy}`);
            }
          }
        }
        else if (Math.random() < SMALL_BUILDING_PROB && 
               x < mapData[0].length - 2 && !isCityRoadTile) {
          for (let dx = 0; dx < 2; dx++) {
            mapData[y][x + dx].type = 'building2x1';
            const currentTile = mapData[y][x + dx];
            currentTile.type = 'building2x1';
            currentTile.structureHeight = 2;
            currentTile.isStructureOrigin = (dx === 0);
            largeStructures.add(`${x + dx},${y}`);
            
          }
        }
        else if (Math.random() < PARK_PROBABILITY) {
          tile.type = 'park';
        }
      }
      if (mapData[y][x].hasRoad) {
        const roadInfo = getRoadRotationNoMap(x, y);
        mapData[y][x].roadType = roadInfo.type;
        
        // Proper road connections
        const connections = [];
        const directions = [
          { dx: -1, dy: 0 }, // left
          { dx: 1, dy: 0 },  // right
          { dx: 0, dy: -1 }, // up
          { dx: 0, dy: 1 }   // down
        ];

        directions.forEach(dir => {
          const nx = x + dir.dx;
          const ny = y + dir.dy;
          if (ny >= 0 && ny < mapData.length && nx >= 0 && nx < mapData[ny].length) {
            if (mapData[ny][nx].hasRoad) {
              connections.push({
                x: nx * tileSize + tileSize/2,
                y: ny * tileSize + tileSize/2
              });
            }
          }
        });

        roadNetwork.addNode(
          x * tileSize + tileSize/2,
          y * tileSize + tileSize/2,
          connections
        );
      }
    }
  }

  // Find closest road tile for player spawn
  for (let y = 0; y < mapData.length; y++) {
    for (let x = 0; x < mapData[y].length; x++) {
      if (mapData[y][x].biome === 'city' && isCityRoad(x, y)) {
        const tileX = x * tileSize;
        const tileY = y * tileSize;
        const dist = Math.hypot(tileX - centerX, tileY - centerY);
        
        if (dist < minDistance) {
          minDistance = dist;
          closestTile = { x: tileX, y: tileY };
        }
      }
    }
  }

  player.x = closestTile.x;
  player.y = closestTile.y;
  return mapData;
}


function determineHouseRotation(x, y) {
  if(y % 3 === 1) return 0;
  else  return 0;
}
  
function getCurrentChunks() {
  const chunks = [];
  const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
  const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
  
  // Load 3x3 area around player
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      chunks.push(`${playerChunkX + x},${playerChunkY + y}`);
    }
  }
  return chunks;
}

function generateTraffic() {
  setInterval(() => {
    if (traffic.length < 20) {
      const roadTiles = [];
      
      // Find valid road tiles
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          if (map[y][x].hasRoad) {
            roadTiles.push({
              x: x * tileSize + tileSize/2,
              y: y * tileSize + tileSize/2,
              rotation: getRoadRotation(x, y).rotation
            });
          }
        }
      }

      if (roadTiles.length > 0) {
        const spawnPoint = roadTiles[Math.floor(Math.random() * roadTiles.length)];
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
        
        const newCar = new Car(
          spawnPoint.x,
          spawnPoint.y,
          'traffic',
          colors[Math.floor(Math.random() * colors.length)]
        );
        
        // Align with road direction
        newCar.angle = spawnPoint.rotation;
        newCar.isTraffic = true;
        newCar.laneOffset = (Math.random() - 0.5) * newCar.track;
        
        traffic.push(newCar);
      }
    }
  }, 3000);
}

async function selectOption(index) {
  const optionText = document.querySelectorAll('.dialogue-option')[index].innerText;
  const response = await currentInteractingNPC.generateDialogue(optionText);
  
  const content = document.getElementById('dialogueContent');
  content.innerHTML = `
    <p><strong>You:</strong> ${optionText}</p>
    <p><strong>${currentInteractingNPC.name}:</strong> ${response.text}</p>
    ${response.options.map((opt, i) => `
      <div class="dialogue-option" onclick="selectOption(${i})">${opt}</div>
    `).join('')}
  `;

  currentInteractingNPC.conversationHistory.push(optionText);
  currentInteractingNPC.conversationHistory.push(response.text);
  
  if(response.options.length === 0) {
    endDialogue();
  }
}

function endDialogue() {
  document.getElementById('dialogueBox').style.display = 'none';
  currentInteractingNPC.interactionCooldown = 300;
  currentInteractingNPC = null;
  document.removeEventListener('keydown', handleDialogueKey);
}

function handleDialogueKey(e) {
  if(e.code === 'Escape') endDialogue();
}

function toggleMenu() {
  const menu = document.getElementById('phoneMenu');
  menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

function manageTraffic() {
  const currentChunks = getCurrentChunks();
  
  // Remove old chunks
  traffic.forEach((car, index) => {
    const carChunkX = Math.floor(car.x / CHUNK_SIZE);
    const carChunkY = Math.floor(car.y / CHUNK_SIZE);
    if (!currentChunks.includes(`${carChunkX},${carChunkY}`)) {
      traffic.splice(index, 1);
    }
  });

  // Add new chunks
  currentChunks.forEach(chunk => {
    if (!loadedChunks.has(chunk)) {
      loadedChunks.add(chunk);
      const [chunkX, chunkY] = chunk.split(',').map(Number);
      spawnTrafficInChunk(chunkX, chunkY);
    }
  });
}
function spawnTrafficInChunk(chunkX, chunkY) {
  const numCars = Math.floor(Math.random() * 3);
  for (let i = 0; i < numCars; i++) {
    const x = chunkX * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
    const y = chunkY * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
    const newCar = new Car(x, y, 'traffic', colors[Math.floor(Math.random() * colors.length)]);
    newCar.isTraffic = true;
    newCar.direction = [DIRECTION.UP, DIRECTION.RIGHT, DIRECTION.DOWN, DIRECTION.LEFT][
      Math.floor(Math.random() * 4)
    ];
    traffic.push(newCar);
  }
}
  
function spawnCar(type) {
  const colors = {
    sedan: '#666666',
    sports: '#FF3300',
    truck: '#00AAFF'
  };
  const newCar = new Car(player.x, player.y, type, colors[type]);
  newCar.enter(player);
  cars.push(newCar);
  toggleMenu();
}

function initializeNPCs() {
  // Add core NPCs
  CORE_NPCS.forEach(data => npcs.push(new NPC(data)));

  // Add faction NPCs around player
  const spawnRadius = 2000;
  for(let i = 0; i < 18; i++) {
    const template = NPC_TEMPLATES[i % NPC_TEMPLATES.length];
    npcs.push(new NPC({
      ...template,
      x: player.x + (Math.random() - 0.5) * spawnRadius,
      y: player.y + (Math.random() - 0.5) * spawnRadius
    }));
  }
}

function startConversation(npc) {
  chatSystem.startChat(npc);
}


function displayMessage(speaker, text) {
  const content = document.getElementById('dialogueContent');
  content.innerHTML += `<p><strong>${speaker}:</strong> ${text}</p>`;
  content.scrollTop = content.scrollHeight; // Auto-scroll
}

async function sendPlayerMessage() {
  const input = document.getElementById('playerInput');
  const message = input.value.trim();
  
  if(message) {
    displayMessage("You", message);
    const response = await currentInteractingNPC.generateResponse(message);
    displayMessage(currentInteractingNPC.name, response);
    input.value = '';
  }
}

function endConversation() {
  // Hide UI
  document.getElementById('dialogueBox').style.display = 'none';
  
  // Process world updates
  currentInteractingNPC.generateWorldUpdate()
    .then(update => applyWorldChanges(update));
  
  currentInteractingNPC = null;
}

function sendPlayerMessage() {
  const input = document.getElementById('playerInput').value;
  conversationManager.sendMessage(input);
}

// Road logic
function isCityRoad(x, y) {
  const cycle = 6;
  const xMod = x % cycle;
  const yMod = y % cycle;
  return (xMod === 0) || (yMod === 0);
}

function isSuburbRoad(x, y) {
  const mainCycle = 15;
  const branchCycle = 3;
  return (x % mainCycle === 0) || (y % branchCycle === 0);
}
  
function isRoadTile(x, y) {
  // Check if map data exists
  if (!map || map.length === 0 || !map[0]) return false;

  // Validate coordinates are integers
  if (!Number.isInteger(x) || !Number.isInteger(y)) return false;

  // Check array bounds
  if (y < 0 || y >= map.length) return false;
  if (x < 0 || x >= map[0].length) return false;

  // Check if row exists
  const row = map[y];
  if (!row) return false;

  // Check if tile exists
  const tile = row[x];
  if (!tile) return false;

  return (tile.biome === 'city' && isCityRoad(x, y)) || 
         (tile.biome === 'suburbs' && isSuburbRoad(x, y));
}

function isRoadTileNoMap(x, y) {
  //if (x < 0 || y < 0 || x >= map[0].length || y >= map.length) return false;
  const noiseValue1 = simplex.noise2D(x * noiseScale, y * noiseScale);
  const noiseValue2 = simplex.noise2D(x * noiseScale2, y * noiseScale2) * 0.5;
  const combinedNoise = noiseValue1 + noiseValue2;

  let biome = 'grassland';
  if (combinedNoise < -0.5) biome = 'water';
  else if (combinedNoise < -0.1) biome = 'suburbs';
  else if (combinedNoise > 0.9) biome = 'city';
  else if (combinedNoise > 0.4) biome = 'suburbs';
  return (biome === 'city' && isCityRoad(x, y)) || 
         (biome === 'suburbs' && isSuburbRoad(x, y));
}

function getRoadRotation(x, y) {
  const neighbors = {
    left: isRoadTile(x - 1, y),
    right: isRoadTile(x + 1, y),
    up: isRoadTile(x, y - 1),
    down: isRoadTile(x, y + 1)
  };
  const count = Object.values(neighbors).filter(v => v).length;

  // Determine road type and rotation
  if (count === 4) return { type: 'x', rotation: 0 };
  if (count === 3) { // T-intersection
    if (!neighbors.up) return { type: 't', rotation: 0 };
    if (!neighbors.down) return { type: 't', rotation: Math.PI };
    if (!neighbors.left) return { type: 't', rotation: -Math.PI/2 };
    return { type: 't', rotation: Math.PI/2 };
  }
  if (count === 2) {
    if (neighbors.left && neighbors.right) return { type: 'straight', rotation: 0 };
    if (neighbors.up && neighbors.down) return { type: 'straight', rotation: Math.PI/2 };
    if (neighbors.right && neighbors.down) return { type: 'turn', rotation: 0 };
    if (neighbors.down && neighbors.left) return { type: 'turn', rotation: Math.PI/2 };
    if (neighbors.left && neighbors.up) return { type: 'turn', rotation: Math.PI };
    if (neighbors.up && neighbors.right) return { type: 'turn', rotation: -Math.PI/2 };
  }
  if (count === 1) { // Dead end
    if (neighbors.left) return { type: 'dead_end', rotation: Math.PI };
    if (neighbors.right) return { type: 'dead_end', rotation: 0 };
    if (neighbors.up) return { type: 'dead_end', rotation: -Math.PI/2 };
    return { type: 'dead_end', rotation: Math.PI/2 };
  }
  return { type: 'straight', rotation: Math.PI / 2 }; // Default
}


function getRoadRotationNoMap(x, y) {
  const neighbors = {
    left: isRoadTileNoMap(x - 1, y),
    right: isRoadTileNoMap(x + 1, y),
    up: isRoadTileNoMap(x, y - 1),
    down: isRoadTileNoMap(x, y + 1)
  };
  const count = Object.values(neighbors).filter(v => v).length;

  // Determine road type and rotation
  if (count === 4) return { type: 'x', rotation: 0 };
  if (count === 3) { // T-intersection
    if (!neighbors.up) return { type: 't', rotation: 0 };
    if (!neighbors.down) return { type: 't', rotation: Math.PI };
    if (!neighbors.left) return { type: 't', rotation: -Math.PI/2 };
    return { type: 't', rotation: Math.PI/2 };
  }
  if (count === 2) {
    if (neighbors.left && neighbors.right) return { type: 'straight', rotation: 0 };
    if (neighbors.up && neighbors.down) return { type: 'straight', rotation: Math.PI/2 };
    if (neighbors.right && neighbors.down) return { type: 'turn', rotation: 0 };
    if (neighbors.down && neighbors.left) return { type: 'turn', rotation: Math.PI/2 };
    if (neighbors.left && neighbors.up) return { type: 'turn', rotation: Math.PI };
    if (neighbors.up && neighbors.right) return { type: 'turn', rotation: -Math.PI/2 };
  }
  if (count === 1) { // Dead end
    if (neighbors.left) return { type: 'dead_end', rotation: Math.PI };
    if (neighbors.right) return { type: 'dead_end', rotation: 0 };
    if (neighbors.up) return { type: 'dead_end', rotation: -Math.PI/2 };
    return { type: 'dead_end', rotation: Math.PI/2 };
  }
  return { type: 'straight', rotation: Math.PI / 2 }; // Default
}

function drawMap() {
  const viewWidth = Math.ceil(canvas.width / tileSize);
  const viewHeight = Math.ceil(canvas.height / tileSize);
  const offsetX = player.x - canvas.width / 2;
  const offsetY = player.y - canvas.height / 2;
  const startTileX = Math.floor(offsetX / tileSize);
  const startTileY = Math.floor(offsetY / tileSize);
  const tileOffsetX = offsetX % tileSize;
  const tileOffsetY = offsetY % tileSize;

  // First pass: Draw base terrain
  for (let y = 0; y <= viewHeight; y++) {
    for (let x = 0; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < map[0].length && mapY >= 0 && mapY < map.length) {
        const tile = map[mapY][mapX];
        let texture = textures.grassland;
        
        if (tile.biome === 'water') texture = textures.water;
        else if (tile.biome === 'city') texture = textures.cityback;
        else if (tile.biome === 'suburbs') texture = textures.suburbs;
        ctx.save();
        ctx.translate(0,0);
        ctx.rotate(determineHouseRotation(x,y));
        ctx.drawImage(texture, x * tileSize - tileOffsetX, y * tileSize - tileOffsetY, tileSize, tileSize);
        ctx.restore();
      }
    }
  }

  // Second pass: Draw structures and roads
  for (let y = -2; y <= viewHeight; y++) {
    for (let x = -2; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < map[0].length && mapY >= 0 && mapY < map.length) {
        const tile = map[mapY][mapX];
        const posX = x * tileSize - tileOffsetX;
        const posY = y * tileSize - tileOffsetY;

        // Draw roads

        // Draw structures

        if(tile.isStructureOrigin){
          switch(tile.type) {
            case 'house':
              ctx.save();
              ctx.translate(posX,posY);
              ctx.rotate(determineHouseRotation(x,y));
              ctx.drawImage(textures.house, posX, posY,tileSize,tileSize);
              ctx.restore();
              break;
            case 'school':
              drawRotatedStructure(posX, posY, textures.school, 2, 2);
              break;
            case 'park':
              ctx.drawImage(textures.park, posX, posY, tileSize, tileSize);
              ctx.restore();

              break;
            case 'building3x3':
              drawRotatedStructure(posX, posY, textures.building3x3, 3, 3);
              break;
            case 'building2x2':
              drawRotatedStructure(posX, posY, textures.building2x2, 2, 2);
              break;
            case 'building2x1':
              drawRotatedStructure(posX, posY, textures.building2x1, 2, 1);
              break;
          }
        }
                // Draw roads
        if (isCityRoad(mapX, mapY) && tile.biome === 'city'|| isSuburbRoad(mapX, mapY)  && tile.biome === 'suburbs') {
          const roadInfo = getRoadRotation(mapX, mapY);
          ctx.save();
          ctx.translate(posX + tileSize/2, posY + tileSize/2);
          ctx.rotate(roadInfo.rotation);
          ctx.drawImage(
            textures[`road_${roadInfo.type}`],
            -tileSize/2,
            -tileSize/2,
            tileSize,
            tileSize
          );
          ctx.restore();
        }
      }
    }
  }
}

function drawRotatedStructure(x, y, texture, width, height) {
  ctx.save();
  ctx.translate(x + (width * tileSize)/2, y + (height * tileSize)/2);
  //ctx.rotate(tile.rotation);
  ctx.drawImage(
    texture,
    -(width * tileSize)/2,
    -(height * tileSize)/2,
    width * tileSize,
    height * tileSize
  );
  ctx.restore();
}

function distance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

// Game loop
function gameLoop(timestamp) {
  // Limit frame rate
  const delta = timestamp - lastFrame;
  if (delta < 1000/FPS) {
    requestAnimationFrame(gameLoop);
    return;
  }
  lastFrame = timestamp;
  
  // Keep player within bounds
    // Player/Car movement
   if (player.currentVehicle) {
    player.currentVehicle.update();
    player.x = player.currentVehicle.x;
    player.y = player.currentVehicle.y;
  } else {
    if (keys.ArrowUp || keys.KeyW) player.y -= player.speed;
    if (keys.ArrowDown || keys.KeyS) player.y += player.speed;
    if (keys.ArrowLeft || keys.KeyA) player.x -= player.speed;
    if (keys.ArrowRight || keys.KeyD) player.x += player.speed;
    
    // Check for nearby cars to enter
    const enterRange = 50;
    const nearbyCar = [...cars, ...traffic].find(car => 
      !car.driver &&
      Math.abs(car.x - player.x) < enterRange &&
      Math.abs(car.y - player.y) < enterRange
    );
  }

  // Keep within bounds
  player.x = Math.max(0, Math.min(mapWidth - tileSize, player.x));
  player.y = Math.max(0, Math.min(mapHeight - tileSize, player.y));

  // Manage traffic chunks
  manageTraffic();
  //checkCurrentCity();

  // Update entities
  cars.forEach(car => car.update());

  // Draw everything
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();

  // Draw cars
  traffic.forEach(car => car.draw(ctx, player.x, player.y));
  cars.forEach(car => car.draw(ctx, player.x, player.y));
  // Throttle NPC updates
  npcs.forEach(npc => {
  npc.update();
  });
  
  if (timestamp - lastTrafficUpdate > TRAFFIC_UPDATE_INTERVAL) {
    traffic.forEach(car => {
      if (distance(car, player) < 2000) { // Only update nearby cars
        car.update();
      }
    });
    lastTrafficUpdate = timestamp;
  }
  // Draw NPCs
  npcs.forEach(npc => npc.draw(ctx, player.x, player.y));
  mapSystem.draw();

  // Draw player if visible
  if (player.visible) {
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(
      canvas.width/2 - playerSize/2,
      canvas.height/2 - playerSize/2,
      playerSize,
      playerSize
    );
  }

  requestAnimationFrame(gameLoop);
}

// Start the game loop after textures load
player.visible = true;
player.currentVehicle = null;
const roadNetwork = new RoadNetwork();
const map = generateMap();
const chatSystem = new ChatSystem();
const mapSystem = new MapSystem();
initializeNPCs()
generateTraffic();
const allTextures = Object.values(textures);
Promise.all(allTextures.map((img) => new Promise((resolve) => (img.onload = resolve)))).then(() => {
  gameLoop();
});
</script>
</body>
</html>
