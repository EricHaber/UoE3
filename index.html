<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic World</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f0f0f0;
    }
    canvas {
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
  <script type="module">
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;
    document.body.appendChild(canvas);

    const simplex = new SimplexNoise();
    const tileSize = 133;  // Make the chunks 3 times smaller
    const roadWidthMain = 40;
    const roadWidthSmall = 10;

    const gameState = {
      player: { x: 400, y: 300, width: 20, height: 20, color: 'blue', speed: 4 },
      mapOffset: { x: 0, y: 0 },
      biomes: {},
      structures: {},
      roads: {},
      npcs: [],
    };

    const keys = {};
    document.addEventListener('keydown', (e) => (keys[e.key] = true));
    document.addEventListener('keyup', (e) => (keys[e.key] = false));

    function generateBiome(x, y) {
      const scale = 0.01;
      const noiseValue = simplex.noise2D(x * scale, y * scale);
      if (noiseValue < -0.3) return 'forest';
      if (noiseValue < 0.3) return 'suburban';
      return 'city';
    }

    function getBiomeColor(biome) {
      return { forest: 'green', suburban: 'lightgreen', city: 'beige' }[biome] || 'black';
    }

    function isTileOccupied(x, y, width, height) {
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          const key = `${x + i},${y + j}`;
          if (gameState.structures[key]) {
            return true; // The tile is occupied
          }
        }
      }
      return false;
    }
    
    function placeStructure(biome, x, y) {
      const seed = Math.random();
      let structure = null;
      let width = 1;
      let height = 1;
    
      if (biome === 'forest') return seed < 0.5 ? 'tree' : null;
      if (biome === 'suburban') {
        if (seed < 0.5) structure = 'house1x1'; 
        else structure = 'house1x2', width = 2, height = 1;
      }
      if (biome === 'city') {
        if (seed < 0.5) structure = 'building2x2', width = 2, height = 2;
        else structure = 'building3x3', width = 3, height = 3;
      }
    
      // Check if the area is free
      if (!isTileOccupied(x, y, width, height)) {
        for (let i = 0; i < width; i++) {
          for (let j = 0; j < height; j++) {
            const key = `${x + i},${y + j}`;
            gameState.structures[key] = structure;
          }
        }
        return structure;
      }
      return null; // Return null if no space available
    }

    function spawnNPCs(biome, x, y) {
      const density = biome === 'city' ? 5 : biome === 'forest' ? 0.1 : 1;
      const npcCount = Math.floor(Math.random() * density);
      for (let i = 0; i < npcCount; i++) {
        const npc = {
          x: x * tileSize + Math.random() * tileSize,
          y: y * tileSize + Math.random() * tileSize,
          destination: null,
          speed: (biome === 'city' ? 1.5 : 0.5) + Math.random() * 0.5,
          pause: 0,
        };
        gameState.npcs.push(npc);
      }
    }

    function generateRoadNetwork(x, y, biome) {
      const roads = [];
      if (biome === 'city') {
        roads.push('verticalMain', 'horizontalMain');
      } else if (biome === 'suburban') {
        if (Math.random() < 0.7) roads.push('smallvertical');
        if (Math.random() < 0.7) roads.push('smallhorizontal');
      } else if (biome === 'forest') {
        if (Math.random() < 0.2) roads.push('smallvertical');
        if (Math.random() < 0.2) roads.push('smallhorizontal');
      }
      return roads;
    }

    function placeRoads(x, y, biome) {
      const key = `${x},${y}`;
      if (!gameState.roads[key]) {
        gameState.roads[key] = generateRoadNetwork(x, y, biome);
      }
    }

    function ensureRoadConnectivity() {
      for (const [key, structures] of Object.entries(gameState.structures)) {
        if (structures && structures.startsWith('house') && !gameState.roads[key]?.length) {
          gameState.roads[key] = ['smallvertical'];
        }
      }
    }

    function drawRoads(tileX, tileY, roads) {
      roads.forEach((type) => {
        ctx.fillStyle = type.includes('Main') ? 'darkgray' : '#d3d3d3';
        const roadWidth = type.includes('Main') ? roadWidthMain : roadWidthSmall;

        if (type.includes('vertical')) {
          ctx.fillRect(tileX + tileSize - roadWidth / 2, tileY, roadWidth, tileSize);
        } else if (type.includes('horizontal')) {
          ctx.fillRect(tileX, tileY + tileSize - roadWidth / 2, tileSize, roadWidth);
        }
      });
    }

    function drawStructures(tileX, tileY, structure) {
      // Draw trees (one tile)
      if (structure === 'tree') {
        ctx.fillStyle = 'darkgreen';
        ctx.beginPath();
        ctx.arc(tileX + tileSize / 2, tileY + tileSize / 2, tileSize / 6, 0, Math.PI * 2);
        ctx.fill();
      }
      // Draw 1x1 house
      else if (structure === 'house1x1') {
        ctx.fillStyle = 'brown';
        ctx.fillRect(tileX + tileSize / 3, tileY + tileSize / 3, tileSize / 3, tileSize / 3);
      }
      // Draw 1x2 house (spans across 2 tiles horizontally)
      else if (structure === 'house1x2') {
        ctx.fillStyle = 'brown';
        ctx.fillRect(tileX + tileSize / 4, tileY + tileSize / 3, tileSize / 2, tileSize / 3);
        // Mark the second tile for the house
        ctx.fillRect(tileX + tileSize, tileY + tileSize / 3, tileSize / 2, tileSize / 3);
      }
      // Draw 2x2 building (spans across 4 tiles)
      else if (structure === 'building2x2') {
        ctx.fillStyle = 'gray';
        ctx.fillRect(tileX + tileSize / 4, tileY + tileSize / 4, tileSize * 2 / 3, tileSize * 2 / 3);
        // Mark the other 3 tiles for the 2x2 building
        ctx.fillRect(tileX + tileSize, tileY + tileSize / 4, tileSize * 2 / 3, tileSize * 2 / 3);
        ctx.fillRect(tileX + tileSize / 4, tileY + tileSize, tileSize * 2 / 3, tileSize * 2 / 3);
        ctx.fillRect(tileX + tileSize, tileY + tileSize, tileSize * 2 / 3, tileSize * 2 / 3);
      }
      // Draw 3x3 building (spans across 9 tiles)
      else if (structure === 'building3x3') {
        ctx.fillStyle = 'darkgray';
        ctx.fillRect(tileX + tileSize / 6, tileY + tileSize / 6, tileSize * 2 / 3, tileSize * 2 / 3);
        // Mark the other 8 tiles for the 3x3 building
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            ctx.fillRect(tileX + i * tileSize / 3, tileY + j * tileSize / 3, tileSize, tileSize);
          }
        }
      }
    }


    function drawMap() {
      const cols = Math.ceil(canvas.width / tileSize) + 2;
      const rows = Math.ceil(canvas.height / tileSize) + 2;

      for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
          const tileX = col * tileSize - (gameState.mapOffset.x % tileSize);
          const tileY = row * tileSize - (gameState.mapOffset.y % tileSize);

          const biomeX = Math.floor((gameState.mapOffset.x + col * tileSize) / tileSize);
          const biomeY = Math.floor((gameState.mapOffset.y + row * tileSize) / tileSize);
          const biomeKey = `${biomeX},${biomeY}`;

          if (!gameState.biomes[biomeKey]) {
            const biome = generateBiome(biomeX, biomeY);
            gameState.biomes[biomeKey] = biome;
            spawnNPCs(biome, biomeX, biomeY);
          }

          const biome = gameState.biomes[biomeKey];
          ctx.fillStyle = getBiomeColor(biome);
          ctx.fillRect(tileX, tileY, tileSize, tileSize);

          if (!gameState.roads[biomeKey]) {
            placeRoads(biomeX, biomeY, biome);
          }

          drawRoads(tileX, tileY, gameState.roads[biomeKey] || []);

          if (!gameState.structures[biomeKey]) {
            const structure = placeStructure(biome, biomeX, biomeY);
            gameState.structures[biomeKey] = structure;
          }

          const structure = gameState.structures[biomeKey];
          if (structure) {
            drawStructures(tileX, tileY, structure);
          }
        }
      }
      ensureRoadConnectivity();
    }

    function drawEntities() {
      ctx.fillStyle = gameState.player.color;
      ctx.fillRect(
        gameState.player.x - gameState.player.width / 2,
        gameState.player.y - gameState.player.height / 2,
        gameState.player.width,
        gameState.player.height
      );

      gameState.npcs.forEach((npc) => {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(
          npc.x - gameState.mapOffset.x,
          npc.y - gameState.mapOffset.y,
          5,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });
    }

    function updateNPCs() {
      gameState.npcs.forEach((npc) => {
        if (npc.pause > 0) {
          npc.pause -= 1;
          return;
        }

        if (!npc.destination) {
          npc.destination = {
            x: npc.x + (Math.random() - 0.5) * tileSize,
            y: npc.y + (Math.random() - 0.5) * tileSize,
          };
        }

        const dx = npc.destination.x - npc.x;
        const dy = npc.destination.y - npc.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        
        if (distance < 5) {
          npc.destination = null;
          npc.pause = Math.random() * 100;
        } else {
          npc.x += (dx / distance) * npc.speed;
          npc.y += (dy / distance) * npc.speed;
        }
      });
    }

    function updatePlayer() {
      if (keys['ArrowUp'] || keys['w']) gameState.mapOffset.y -= gameState.player.speed;
      if (keys['ArrowDown'] || keys['s']) gameState.mapOffset.y += gameState.player.speed;
      if (keys['ArrowLeft'] || keys['a']) gameState.mapOffset.x -= gameState.player.speed;
      if (keys['ArrowRight'] || keys['d']) gameState.mapOffset.x += gameState.player.speed;
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      drawEntities();
      updateNPCs();
      updatePlayer();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
