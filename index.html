<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Road Generation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f0f0f0;
    }
    canvas {
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
  <script type="module">
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;
    document.body.appendChild(canvas);

    const simplex = new SimplexNoise();
    const gameState = {
      player: { x: 400, y: 300, width: 20, height: 20, color: 'blue', speed: 4 },
      mapOffset: { x: 0, y: 0 },
      biomes: {},
      structures: {},
      roads: {},
      npcs: [],
    };

    const keys = {};
    document.addEventListener('keydown', (e) => (keys[e.key] = true));
    document.addEventListener('keyup', (e) => (keys[e.key] = false));

    function generateBiome(x, y) {
      const scale = 0.01;
      const noiseValue = simplex.noise2D(x * scale, y * scale);
      if (noiseValue < -0.3) return 'forest';
      if (noiseValue < 0.3) return 'suburban';
      return 'city';
    }

    function getBiomeColor(biome) {
      return { forest: 'green', suburban: 'lightgreen', city: 'beige' }[biome] || 'black';
    }

    function placeStructure(biome, x, y) {
      const seed = Math.random();
      if (biome === 'forest' && seed < 0.2) return 'tree';
      if (biome === 'suburban' && seed < 0.4) return 'house';
      if (biome === 'city' && seed < 0.5) return 'building';
      return null;
    }

    function placeRoads(x, y, biome) {
      if (!gameState.roads[`${x},${y}`]) gameState.roads[`${x},${y}`] = [];

      if (biome === 'city') {
        // Main roads every 3 tiles
        if (x % 3 === 0) gameState.roads[`${x},${y}`].push('verticalMain');
        if (y % 3 === 0) gameState.roads[`${x},${y}`].push('horizontalMain');

        // Smaller connecting roads near structures
        if (gameState.structures[`${x},${y}`] === 'building') {
          gameState.roads[`${x},${y}`].push('smallVertical');
        }
      } else if (biome === 'suburban') {
        // Smaller roads only near houses
        if (gameState.structures[`${x},${y}`] === 'house') {
          if (Math.random() < 0.5) gameState.roads[`${x},${y}`].push('smallVertical');
          else gameState.roads[`${x},${y}`].push('smallHorizontal');
        }
      } else if (biome === 'forest') {
        // Occasionally place a small road
        if (Math.random() < 0.1) {
          if (Math.random() < 0.5) gameState.roads[`${x},${y}`].push('smallVertical');
          else gameState.roads[`${x},${y}`].push('smallHorizontal');
        }
      }
    }

    function createNPC(x, y, biome) {
      const npcSpeed = biome === 'city' ? 1.5 : biome === 'suburban' ? 1 : 0.5;
      return {
        x: x * 400 + Math.random() * 400,
        y: y * 400 + Math.random() * 400,
        speed: npcSpeed,
        direction: Math.random() * 2 * Math.PI,
      };
    }

    function spawnNPCs(biomeX, biomeY) {
      const biome = gameState.biomes[`${biomeX},${biomeY}`];
      let spawnCount = 0;

      if (biome === 'forest') {
        spawnCount = Math.random() < 0.05 ? 1 : 0;
      } else if (biome === 'suburban') {
        spawnCount = 2;
      } else if (biome === 'city') {
        spawnCount = 4;
      }

      for (let i = 0; i < spawnCount; i++) {
        const npc = createNPC(biomeX, biomeY, biome);
        gameState.npcs.push(npc);
      }
    }

    function drawMap() {
      const tileSize = 400;
      const cols = Math.ceil(canvas.width / tileSize) + 2;
      const rows = Math.ceil(canvas.height / tileSize) + 2;

      for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
          const tileX = col * tileSize - (gameState.mapOffset.x % tileSize);
          const tileY = row * tileSize - (gameState.mapOffset.y % tileSize);

          const biomeX = Math.floor((gameState.mapOffset.x + col * tileSize) / tileSize);
          const biomeY = Math.floor((gameState.mapOffset.y + row * tileSize) / tileSize);

          const biomeKey = `${biomeX},${biomeY}`;
          if (!gameState.biomes[biomeKey]) {
            gameState.biomes[biomeKey] = generateBiome(biomeX, biomeY);
            spawnNPCs(biomeX, biomeY);
          }

          ctx.fillStyle = getBiomeColor(gameState.biomes[biomeKey]);
          ctx.fillRect(tileX, tileY, tileSize, tileSize);

          const structureKey = `${biomeX},${biomeY}`;
          if (!gameState.structures[structureKey]) {
            const structure = placeStructure(gameState.biomes[biomeKey], biomeX, biomeY);
            gameState.structures[structureKey] = structure;
          }

          const structure = gameState.structures[structureKey];
          if (structure) {
            ctx.fillStyle = structure === 'house' ? 'brown' : 'black';
            ctx.fillRect(tileX + tileSize / 3, tileY + tileSize / 3, tileSize / 3, tileSize / 3);
          }

          placeRoads(biomeX, biomeY, gameState.biomes[biomeKey]);
          (gameState.roads[`${biomeX},${biomeY}`] || []).forEach((type) => {
            ctx.fillStyle = type.includes('Main') ? 'darkgray' : 'lightgray';
            if (type.includes('vertical')) ctx.fillRect(tileX + tileSize / 2 - 10, tileY, 20, tileSize);
            else if (type.includes('horizontal')) ctx.fillRect(tileX, tileY + tileSize / 2 - 10, tileSize, 20);
          });
        }
      }
    }

    function drawEntities() {
      ctx.fillStyle = gameState.player.color;
      ctx.fillRect(
        gameState.player.x - gameState.player.width / 2,
        gameState.player.y - gameState.player.height / 2,
        gameState.player.width,
        gameState.player.height
      );

      gameState.npcs.forEach((npc) => {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(
          npc.x - gameState.mapOffset.x,
          npc.y - gameState.mapOffset.y,
          10,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });
    }

    function update() {
      if (keys['ArrowUp']) gameState.mapOffset.y -= gameState.player.speed;
      if (keys['ArrowDown']) gameState.mapOffset.y += gameState.player.speed;
      if (keys['ArrowLeft']) gameState.mapOffset.x -= gameState.player.speed;
      if (keys['ArrowRight']) gameState.mapOffset.x += gameState.player.speed;

      gameState.npcs.forEach((npc) => {
        npc.x += Math.cos(npc.direction) * npc.speed;
        npc.y += Math.sin(npc.direction) * npc.speed;

        if (Math.random() < 0.02) npc.direction = Math.random() * 2 * Math.PI;
      });
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      update();
      drawMap();
      drawEntities();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
