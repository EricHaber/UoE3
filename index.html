<!DOCTYPE html>
<html>
<head>
  <title>UoE3 Game</title>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #phoneMenu {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      height: 500px;
      background: rgba(0,0,0,0.9);
      color: white;
      display: none;
      flex-direction: column;
      border-radius: 15px;
      padding: 15px;
      z-index: 1000;
      border: 1px solid #333;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    .menu-item { 
      padding: 10px;
      margin: 5px 0;
      background: #2d2d2d;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .menu-item:hover {
      background: #3d3d3d;
    }
    /* Chat Interface */
    
    #closePhoneMenu {
      color: #ff4444;
      font-size: 24px;
      cursor: pointer;
      padding: 0 10px;
    }

    #phoneMenuHeader {
      padding: 0;
      margin: 0 0 15px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

  #chatContainer {
    position: fixed;
    bottom: 80px;
    right: 20px;
    width: 350px;
    height: 500px;
    background: rgba(0,0,0,0.9);
    border-radius: 15px;
    display: none;
    flex-direction: column;
    color: white;
    border: 1px solid #333;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    z-index: 1000;
  }

  #chatHeader {
    padding: 15px;
    border-bottom: 1px solid #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  #closeChat {
    color: #ff4444;
    font-size: 24px;
    cursor: pointer;
    padding: 0 10px;
  }

  #chatMessages {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .message {
    max-width: 80%;
    padding: 10px 15px;
    border-radius: 15px;
    animation: messageAppear 0.3s ease;
  }

  .npc-message {
    background: #2d2d2d;
    align-self: flex-start;
  }

  .player-message {
    background: #0078d4;
    align-self: flex-end;
  }

  #chatInputContainer {
    padding: 15px;
    border-top: 1px solid #333;
  }

  #chatInput {
    width: 100%;
    padding: 10px;
    border-radius: 25px;
    border: none;
    background: #1e1e1e;
    color: white;
  }

  /* Phone Contacts */
  #phoneContacts {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 300px;
    height: 500px;
    background: rgba(0,0,0,0.9);
    display: none;
    flex-direction: column;
    border-radius: 15px;
    padding: 15px;
    z-index: 1001;
  }

  .contact {
    padding: 10px;
    margin: 5px 0;
    background: #2d2d2d;
    border-radius: 10px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .contact:hover {
    background: #3d3d3d;
  }

  @keyframes messageAppear {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
 
<div id="dialogueBox" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; max-width: 500px;">
  <div id="dialogueContent"></div>
  <div id="dialogueOptions" style="margin-top: 10px;"></div>
  <input type="text" id="playerInput" style="margin-top: 10px; width: 100%; display: none;">
  <button onclick="sendPlayerMessage()" style="margin-top: 5px; display: none;">Send</button>
</div>

<div id="phoneMenu">
  <div id="phoneMenuHeader">
    <h3 style="margin: 0;">Phone</h3>
    <div id="closePhoneMenu" onclick="togglePhoneMenu()">×</div>
  </div>
  <div class="menu-item" onclick="spawnCar('sedan')">Spawn Sedan</div>
  <div class="menu-item" onclick="spawnCar('sports')">Spawn Sports Car</div>
  <div class="menu-item" onclick="spawnCar('truck')">Spawn Truck</div>
  <div class="menu-item" onclick="showContacts()">Contacts</div>
</div>

<div id="chatContainer">
  <div id="chatHeader">
    <span id="chatTitle">Conversation</span>
    <div id="closeChat">×</div>
  </div>
  <div id="chatMessages"></div>
  <div id="chatInputContainer">
    <input type="text" id="chatInput" placeholder="Type your message...">
  </div>
</div>

<div id="phoneContacts">
  <div id="phoneContactsHeader">
    <h3 style="margin: 0;">Contacts</h3>
    <div id="closeContacts" onclick="toggleContacts()">×</div>
  </div>
  <div id="contactsList"></div>
</div>

<div id="miniMap" style="position: fixed; top: 20px; right: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.8); border: 2px solid #fff;">
  <canvas id="mapCanvas"></canvas>
</div>

<div id="fullMap" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999;">
  <canvas id="fullMapCanvas"></canvas>
  <div style="position: absolute; top: 20px; right: 20px; color: white; cursor: pointer;" onclick="toggleFullMap()">×</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mapWidth = 300000;
const mapHeight = 300000;
const tileSize = 400; // Adjusted for zoom
const playerSize = 16;
const noiseScale = 0.02;
const noiseScale2 = 0.05;
const DIRECTION = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
const cars = [];
const traffic = [];
const HOUSE_PROBABILITY = 0.3;
const CHUNK_SIZE = 1000; // World units
const loadedChunks = new Set();
const npcs = [];
let currentInteractingNPC = null;
const NPC_UPDATE_INTERVAL = 5000; // Update NPC behavior every 5 seconds
const DIALOGUE_RANGE = 100; // Distance for conversation
const API_KEY = "Your OPEN AI API Key";




//console.log("API Key:", API_KEY);
  
const storyState = {
  cityMood: "calm",
  recentEvents: [],
  playerReputation: 0
};

canvas.width = 1920; // Fixed viewport size
canvas.height = 1080;

const simplex = new SimplexNoise();

const player = {
  x: 100,
  y: 100,
  speed: 2,
  visible: true,
  currentVehicle: null
};

const CORE_NPCS = [
  {
    name: "Mayor Evelyn Cross",
    role: "City Mayor",
    faction: "Government",
    personality: "Charismatic reformer pushing urban development",
    knowledge: ["City Budget", "Infrastructure Plans"],
    x: player.x + 500,  // Near starting position
    y: player.y + 500
  },
  {
    name: "Dr. Rajesh Verma",
    role: "Climate Scientist",
    faction: "University",
    personality: "Anxious researcher tracking ecological changes",
    knowledge: ["Climate Data", "Renewable Energy"],
    x: player.x - 500,
    y: player.y - 500
  }
];

const NPC_TEMPLATES = [
  // Government Faction
  {
    name: "Councilwoman Diane Hartman",
    role: "Urban Development Director",
    faction: "Government",
    personality: "Driven technocrat obsessed with modernization",
    knowledge: ["Zoning Laws", "Public Contracts"],
    keyValue: "Progress at any cost",
    secret: "Taking kickbacks from construction firms"
  },
  {
    name: "Agent Marcus Cole",
    role: "Public Safety Commissioner",
    faction: "Government",
    personality: "Paranoid former military strategist",
    knowledge: ["Surveillance Networks", "Gang Activity"],
    keyValue: "Order above all else",
    secret: "Maintains blacksite prison facilities"
  },

  // University Faction
  {
    name: "Dr. Elara Voss",
    role: "AI Ethics Professor",
    faction: "University",
    personality: "Idealistic but pragmatic philosopher",
    knowledge: ["Machine Learning", "Neuroethics"],
    keyValue: "Prevent technological dystopia",
    secret: "Developing unauthorized AI models"
  },
  {
    name: "Liam Chen",
    role: "Student Union Leader",
    faction: "University", 
    personality: "Charismatic activist with trust issues",
    knowledge: ["Protest Tactics", "University Finances"],
    keyValue: "Student power movement",
    secret: "Funding from anonymous donor"
  },

  // Press Faction
  {
    name: "Victoria Pryce",
    role: "Investigative Journalist",
    faction: "Press",
    personality: "Cynical truth-seeker with alcohol problem",
    knowledge: ["Political Scandals", "Corporate Espionage"],
    keyValue: "Destroy corrupt institutions",
    secret: "Being blackmailed by mayor's office"
  },
  {
    name: "Omar Khalid",
    role: "Tech Reporter",
    faction: "Press",
    personality: "Obsessive gadget enthusiast",
    knowledge: ["Emerging Tech", "Startup Culture"],
    keyValue: "Technological utopianism",
    secret: "Running illegal darknet review site"
  },

  // Public Works Faction
  {
    name: "Ingrid Bjornsson",
    role: "Waste Management Chief",
    faction: "Public Works",
    personality: "No-nonsense efficiency expert",
    knowledge: ["Recycling Systems", "Underground Tunnels"],
    keyValue: "Keep city functioning smoothly",
    secret: "Black market disposal service"
  },
  {
    name: "Dr. Kwame Nkosi",
    role: "Environmental Impact Officer",
    faction: "Public Works",
    personality: "Guilt-ridden former oil executive",
    knowledge: ["Pollution Data", "Green Tech"],
    keyValue: "Ecological redemption",
    secret: "Faking emission reports"
  },

  // Criminal Faction
  {
    name: "Nikolai 'The Tailor' Volkov",
    role: "Forgery Specialist",
    faction: "Criminal",
    personality: "Perfectionist with artistic temperament",
    knowledge: ["Document Systems", "Security Features"],
    keyValue: "Craftsmanship in illegality",
    secret: "Police informant"
  },
  {
    name: "Jiao Long",
    role: "Cybercrime Broker",
    faction: "Criminal",
    personality: "Paranoid digital anarchist",
    knowledge: ["Darknet Markets", "Encryption Systems"],
    keyValue: "Information wants to be free",
    secret: "Working on dead man's switch"
  },

  // Neutral/Cross-Faction
  {
    name: "Reverend Micah Blake",
    role: "Community Leader",
    faction: "Neutral",
    personality: "Empathetic mediator with dark past",
    knowledge: ["Gang Territories", "Social Programs"],
    keyValue: "Urban reconciliation",
    secret: "Former drug kingpin"
  },
  {
    name: "Kira 'Ghost' Nakamura",
    role: "Urban Explorer",
    faction: "Neutral",
    personality: "Adrenaline-junkie historian",
    knowledge: ["Abandoned Sites", "City Archives"],
    keyValue: "Preserve hidden history",
    secret: "Found doomsday bunker"
  },
  {
    name: "The Architect",
    role: "Mysterious Benefactor",
    faction: "Unknown",
    personality: "Cryptic master manipulator",
    knowledge: ["City Blueprints", "Secret Projects"],
    keyValue: "Social experimentation",
    secret: "AI controlling multiple identities"
  }
];

const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
  KeyW: false,
  KeyA: false,
  KeyS: false,
  KeyD: false,
  KeyF: false,
  KeyP: false,
  Enter: false
};


document.addEventListener('keydown', (e) => {

//  if(e.code === 'KeyE') handleInteractionKey();
  if(e.code === 'Enter' && currentInteractingNPC) sendPlayerMessage();
});


document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if(e.code === 'KeyP') {
    toggleMenu();
  }
  const enterRange = 50;
    const nearbyCar = [...cars, ...traffic].find(car => 
      !car.driver &&
      Math.abs(car.x - player.x) < enterRange &&
      Math.abs(car.y - player.y) < enterRange
    );
  if(e.code === 'KeyF' && nearbyCar) nearbyCar.enter(player);
  else if(e.code === 'KeyF' && player.currentVehicle) player.currentVehicle.exit();
  
  if(e.code === 'KeyE') handleInteractionKey();
  if(e.code === 'Enter' && currentInteractingNPC) sendPlayerMessage();
  if(e.code === 'KeyM')toggleFullMap();
});
document.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});




// Textures
const textures = {
  water: new Image(),
  city: new Image(),
  suburbs: new Image(),
  grassland: new Image(),
  road_straight: new Image(),
  road_turn: new Image(),
  road_t: new Image(),
  road_x: new Image(),
  road_dead_end: new Image(),
  house: new Image(),
  driveway: new Image()
};

// Load textures
textures.water.src = 'water.png';
textures.city.src = 'city.png';
textures.suburbs.src = 'suburbs.png';
textures.grassland.src = 'grassland.png';
textures.road_straight.src = 'road_straight.png';
textures.road_turn.src = 'road_turn.png';
textures.road_t.src = 'road_t.png';
textures.road_x.src = 'road_x.png';
textures.road_dead_end.src = 'road_dead_end.png';
textures.house.src = 'house.png';
textures.driveway.src = 'driveway.png';

class Tile {
  constructor(biome, hasHouse = false, driveway = null) {
    this.biome = biome;
    this.hasHouse = hasHouse;
    this.driveway = driveway;
  }
}
  
class ConversationManager {
  constructor() {
    this.currentNPC = null;
    this.isWaiting = false;
  }

  async start(npc) {
    this.currentNPC = npc;
    this.showDialogue(`<p><strong>${npc.name}:</strong> ${await this.getGreeting()}</p>`);
  }

  async getGreeting() {
    const response = await this.currentNPC.queryOpenAI(
      `Generate greeting from ${this.currentNPC.name} (${this.currentNPC.role})`
    );
    return response;
  }

  async sendMessage(message) {
    if(this.isWaiting) return;
    
    this.isWaiting = true;
    const response = await this.currentNPC.generateResponse(message);
    this.showResponse(response);
    this.isWaiting = false;
  }

  async end() {
    const worldUpdate = await this.currentNPC.generateWorldUpdate();
    this.applyWorldUpdate(worldUpdate);
    this.currentNPC = null;
  }

  // Add showDialogue, showResponse, applyWorldUpdate methods
}

class NPC {
  constructor(roleData) {
    this.x = roleData.x;
    this.y = roleData.y;
    this.name = roleData.name;
    this.role = roleData.role;
    this.faction = roleData.faction;
    this.personality = roleData.personality;
    this.knowledge = roleData.knowledge;
    this.conversationHistory = [];
    this.interactionCooldown = 0;
    this.speed = 0.5;
    this.destination = this.getRandomDestination();
    this.city = 0;//city;
    this.currentPath = [];
    this.isMoving = false;
    this.lastKnownPosition = { x: roleData.x, y: roleData.y };
    this.isInConversation = false;
  }


  generateName() {
    const names = ["Alex", "Sam", "Jordan", "Taylor", "Casey"];
    return names[Math.floor(Math.random() * names.length)];
  }

  generatePersonality() {
    const traits = {
      openness: Math.random(),
      conscientiousness: Math.random(),
      extraversion: Math.random(),
      agreeableness: Math.random(),
      neuroticism: Math.random()
    };
    return traits;
  }

  async generateResponse(message) {
    // Add to conversation history
    this.conversationHistory.push(['player', message]);
    
    const response = await this.queryOpenAI(
      `Respond as ${this.name} to: "${message}". Keep it under 2 sentences.`
    );
    
    this.conversationHistory.push(['npc', response]);
    return response;
  }

  async updateBehavior() {
    if (Date.now() - this.lastAIUpdate > NPC_UPDATE_INTERVAL) {
      try {
        const prompt = `In a city that's currently ${storyState.cityMood}, ${this.name}, who is ${this.describePersonality()}, is currently ${this.currentAction}. Recent events: ${storyState.recentEvents.join(", ")}. What should they do next? Respond with ONLY a JSON object containing: {action: "string", destination: {x: number, y: number}, mood: "string"}`;
        
        const response = await this.queryOpenAI(prompt);
        const behavior = JSON.parse(response);
        
        this.currentAction = behavior.action;
        this.destination = behavior.destination;
        this.lastAIUpdate = Date.now();
        
        if(behavior.mood) {
          this.mood = behavior.mood;
        }
      } catch (error) {
        console.error("AI behavior error:", error);
      }
    }
  }

  describePersonality() {
    return `openness ${this.personality.openness.toFixed(2)}, conscientiousness ${this.personality.conscientiousness.toFixed(2)}, extraversion ${this.personality.extraversion.toFixed(2)}, agreeableness ${this.personality.agreeableness.toFixed(2)}, neuroticism ${this.personality.neuroticism.toFixed(2)}`;
  }

  async queryOpenAI(prompt) {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [{
          role: "user",
          content: prompt
        }],
        temperature: 0.7,
        max_tokens: 150
      })
    });

    const data = await response.json();
    return data.choices[0].message.content.trim();
  }
  generateNewPath() {
    // Get road edge nodes from current tile
    //const currentTile = this.getCurrentTile();
    //this.currentPath = currentTile.getSidewalkPath();
    return 1;
  }


  getRandomDestination() {
    return {
      x: this.x + (Math.random() - 0.5) * 500,
      y: this.y + (Math.random() - 0.5) * 500
    };
  }

  async generateDialogue(playerInput = null) {
    try {
      const prompt = this.createDialoguePrompt(playerInput);
      const response = await this.queryOpenAI(prompt);
      return this.processAIResponse(response);
    } catch (error) {
      console.error("Dialogue error:", error);
      return {text: "I can't talk right now.", options: []};
    }
  }

  createDialoguePrompt(playerInput) {
    return `In a ${storyState.cityMood} city, ${this.name} (${this.describePersonality()}) is talking to a player with reputation ${storyState.playerReputation}. 
    Previous conversation: ${this.conversationHistory.slice(-3).join(" | ")}
    ${playerInput ? `Player says: "${playerInput}"` : "Player initiates conversation"}
    Generate natural dialogue response and up to 3 options. Respond ONLY with JSON: {text: "string", options: ["string"], storyEffects: {}}`;
  }

  processAIResponse(response) {
    try {
      const data = JSON.parse(response);
      if(data.storyEffects) {
        Object.assign(storyState, data.storyEffects);
        if(data.storyEffects.recentEvents) {
          storyState.recentEvents.push(data.storyEffects.recentEvents);
          if(storyState.recentEvents.length > 5) storyState.recentEvents.shift();
        }
      }
      return data;
    } catch {
      return {text: response, options: []};
    }
  }
  async generateWorldUpdate() {
    const prompt = `Generate world changes based on conversation with ${this.name}. 
    Current state: ${storyState.cityMood}, Recent events: ${storyState.recentEvents.join(", ")}`;
    
    const update = await this.queryOpenAI(prompt);
    return JSON.parse(update);
  }

  draw(ctx, playerX, playerY) {
    const screenX = this.x - playerX + canvas.width/2;
    const screenY = this.y - playerY + canvas.height/2;
    
    // Only draw if in view
    if (Math.abs(screenX) < canvas.width * 1.5 && Math.abs(screenY) < canvas.height * 1.5) {
      ctx.fillStyle = '#00FF00';
      ctx.beginPath();
      ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw name
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(this.name, screenX, screenY - 12);
    }
  }

  update() {
    if(this.isInConversation) return;
    
    // Pathfinding along road edges
    if(this.currentPath.length === 0) {
      this.getRandomDestination(); //generateNewPath();
    } else {
      const nextNode = this.currentPath[0];
      const dx = nextNode.x - this.x;
      const dy = nextNode.y - this.y;
      
      if(Math.hypot(dx, dy) < 5) {
        this.currentPath.shift();
      } else {
        this.x += (dx / Math.hypot(dx, dy)) * this.speed;
        this.y += (dy / Math.hypot(dx, dy)) * this.speed;
      }
    }
  }
}

class Car {
  constructor(x, y, type, color) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.color = color;

    // Vehicle performance characteristics
    switch(type) {
      case 'sports':
        this.maxSpeed = 4;
        this.acceleration = 0.01;
        this.minTurningRadius = 5;
        this.grip = 1.2;
        this.steeringResponse = 0.04;
        break;
      case 'truck':
        this.maxSpeed = 2;
        this.acceleration = 0.005;
        this.minTurningRadius = 7;
        this.grip = 2.0;
        this.steeringResponse = 0.04;
        break;
      default: // sedan
        this.maxSpeed = 3;
        this.acceleration = 0.0075;
        this.minTurningRadius = 6;
        this.grip = 1.6;
        this.steeringResponse = 0.03;
    }

    this.angle = 0;
    this.width = 30;
    this.height = 15;
    this.driver = null;
    this.active = false;
    this.isTraffic = false;
    this.currentSpeed = 0;
    this.deceleration = 0.002;
    this.wheelBase = 20; // Distance between front and rear axles
    this.track = this.width * 0.6; // Distance between left/right wheels
  }

  enter(player) {
    this.driver = player;
    this.active = true;
    player.visible = false;
    player.currentVehicle = this;
    this.currentSpeed = 0;
    this.x = player.x;
    this.y = player.y;
  }

  exit() {
    if (this.driver) {
      this.driver.x = this.x;
      this.driver.y = this.y;
      this.driver.visible = true;
      this.driver.currentVehicle = null;
      this.driver = null;
    }
    this.active = false;
  }

  draw(ctx, playerX, playerY) {
    const screenX = this.x - playerX + canvas.width/2 - this.width/2;
    const screenY = this.y - playerY + canvas.height/2 - this.height/2;
    
    ctx.save();
    ctx.translate(screenX + this.width/2, screenY + this.height/2);
    ctx.rotate(this.angle);
    ctx.fillStyle = this.color;
    
    // Draw car body
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    
    // Draw wheels
    ctx.fillStyle = '#333';
    const wheelWidth = 8;
    const wheelHeight = 4;
    const axleFront = this.wheelBase/2;
    const axleRear = -this.wheelBase/2;
    
    // Front wheels
    ctx.fillRect(-this.track/2, axleFront - wheelHeight/2, wheelWidth, wheelHeight);
    ctx.fillRect(this.track/2 - wheelWidth, axleFront - wheelHeight/2, wheelWidth, wheelHeight);
    
    // Rear wheels
    ctx.fillRect(-this.track/2, axleRear - wheelHeight/2, wheelWidth, wheelHeight);
    ctx.fillRect(this.track/2 - wheelWidth, axleRear - wheelHeight/2, wheelWidth, wheelHeight);
    
    ctx.restore();
  }

  update() {
    if (this.active && this.driver) {
      // Steering physics
      let steeringInput = 0;
      if (keys.KeyA || keys.ArrowLeft) steeringInput -= 1;
      if (keys.KeyD || keys.ArrowRight) steeringInput += 1;

      if (steeringInput !== 0 && this.currentSpeed !== 0) {
        const speed = Math.abs(this.currentSpeed);
        const maxTheoreticalSpeed = Math.sqrt(this.grip * this.minTurningRadius);
        let effectiveRadius;

        if (speed <= maxTheoreticalSpeed) {
          effectiveRadius = this.minTurningRadius;
        } else {
          effectiveRadius = (speed ** 2) / this.grip;
        }

        // Improved speed-sensitive steering
        const baseAngularVelocity = (this.currentSpeed / effectiveRadius) * steeringInput;
        const speedFactor = Math.min(1, speed / this.maxSpeed);
        const adjustedAngular = baseAngularVelocity * (1 - speedFactor * 0.7);
        
        this.angle += adjustedAngular * this.steeringResponse;
      }

      // Acceleration physics
      if (keys.KeyW || keys.ArrowUp) {
        this.currentSpeed = Math.min(
          this.currentSpeed + this.acceleration,
          this.maxSpeed
        );
      } else if (keys.KeyS || keys.ArrowDown) {
        this.currentSpeed = Math.max(
          this.currentSpeed - this.acceleration * 2,
          -this.maxSpeed * 0.5
        );
      } else {
        // Natural deceleration with rolling resistance
        const decel = this.currentSpeed > 0 ? 
          -this.deceleration * (1 + this.currentSpeed/this.maxSpeed) : 
          this.deceleration * (1 - this.currentSpeed/this.maxSpeed);
        this.currentSpeed += decel;
        if (Math.abs(this.currentSpeed) < 0.1) this.currentSpeed = 0;
      }
      
      // Apply movement with momentum
      const moveAngle = this.angle;
      this.x += Math.cos(moveAngle) * this.currentSpeed;
      this.y += Math.sin(moveAngle) * this.currentSpeed;
    } else if (this.isTraffic) {
      // Simplified traffic movement with basic physics
      this.currentSpeed = Math.min(
        this.currentSpeed + this.acceleration * 0.5,
        this.maxSpeed * 0.8
      );
      
      // Gentle traffic steering
      if (Math.random() < 0.01) {
        const maxTurnSpeed = Math.sqrt(this.grip * this.minTurningRadius);
        const speedFactor = Math.min(1, this.currentSpeed / maxTurnSpeed);
        this.angle += (Math.random() - 0.5) * this.steeringResponse * (1 - speedFactor);
      }
      
      this.x += Math.cos(this.angle) * this.currentSpeed;
      this.y += Math.sin(this.angle) * this.currentSpeed;
    }
  }
}

class ChatSystem {
  constructor() {
    this.knownNPCs = new Map();
    this.currentChat = null;
    
    // Event Listeners
    document.getElementById('closeChat').addEventListener('click', () => this.closeChat());
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if(e.key === 'Enter') this.sendMessage();
    });
    
    document.addEventListener('keydown', (e) => {
      if(e.key === 'Escape') this.closeChat();
      if(e.key === 'KeyP' && !this.currentChat) this.togglePhoneContacts();
    });
  }

  startChat(npc) {
    this.currentChat = npc;
    if(!this.knownNPCs.has(npc.name)) {
      this.knownNPCs.set(npc.name, npc);
      this.updateContacts();
    }
    
    document.getElementById('chatContainer').style.display = 'flex';
    document.getElementById('chatTitle').textContent = npc.name;
    this.loadHistory(npc);
  }

  async sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    if(!message) return;

    // Add player message
    this.addMessage(message, 'player');
    input.value = '';

    // Get NPC response
    const response = await this.currentChat.generateResponse(message);
    this.addMessage(response, 'npc');
  }

  addMessage(text, sender) {
    const messages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    messageDiv.textContent = text;
    messages.appendChild(messageDiv);
    messages.scrollTop = messages.scrollHeight;
  }

  loadHistory(npc) {
    const messages = document.getElementById('chatMessages');
    messages.innerHTML = '';
    npc.conversationHistory.forEach(([type, text]) => {
      this.addMessage(text, type === 'player' ? 'player' : 'npc');
    });
  }

  closeChat() {
    document.getElementById('chatContainer').style.display = 'none';
    this.currentChat = null;
  }

  togglePhoneContacts() {
    const contacts = document.getElementById('phoneContacts');
    contacts.style.display = contacts.style.display === 'none' ? 'flex' : 'none';
  }

  updateContacts() {
    const list = document.getElementById('contactsList');
    list.innerHTML = '';
    
    this.knownNPCs.forEach(npc => {
      const contact = document.createElement('div');
      contact.className = 'contact';
      contact.textContent = npc.name;
      contact.addEventListener('click', () => this.startPhoneChat(npc));
      list.appendChild(contact);
    });
  }

  startPhoneChat(npc) {
    this.togglePhoneContacts();
    this.startChat(npc);
  }
}

class PhoneSystem {
  constructor() {
    this.contacts = new Map();
    this.currentCall = null;
  }

  addContact(npc) {
    this.contacts.set(npc.id, {
      name: npc.name,
      number: this.generatePhoneNumber(),
      city: npc.city
    });
  }

  generatePhoneNumber() {
    return `555-${Math.floor(100 + Math.random() * 900)}-${Math.floor(1000 + Math.random() * 9000)}`;
  }

  startCall(npc) {
    this.currentCall = npc;
    npc.isInConversation = true;
    // Show chat interface
  }
}

class MapSystem {
  constructor() {
    this.mapCanvas = document.getElementById('mapCanvas');
    this.mapCtx = this.mapCanvas.getContext('2d');
    this.mapCanvas.width = 200;
    this.mapCanvas.height = 200;
  }

  draw() {
    this.mapCtx.fillStyle = 'rgba(0,0,0,0.8)';
    this.mapCtx.fillRect(0, 0, 200, 200);
    
    // Draw player position
    this.mapCtx.fillStyle = '#ff0000';
    this.mapCtx.beginPath();
    this.mapCtx.arc(100, 100, 3, 0, Math.PI * 2);
    this.mapCtx.fill();
    
    // Draw NPCs
    npcs.forEach(npc => {
      const dx = npc.x - player.x;
      const dy = npc.y - player.y;
      if(Math.abs(dx) < 2000 && Math.abs(dy) < 2000) {
        this.mapCtx.fillStyle = '#00ff00';
        this.mapCtx.beginPath();
        this.mapCtx.arc(100 + dx/20, 100 + dy/20, 2, 0, Math.PI * 2);
        this.mapCtx.fill();
      }
    });
  }
}

let interactionCooldown = false;

function handleInteractionKey() {
  if(interactionCooldown || !player.visible) return;
  interactionCooldown = true;

  if(currentInteractingNPC) {
    endConversation();
  } else {
    const nearestNPC = findNearestNPC();
    if(nearestNPC) startConversation(nearestNPC);
  }
}

function findNearestNPC() {
  let closest = null;
  let minDist = Infinity;

  npcs.forEach(npc => {
    const dx = npc.x - player.x;
    const dy = npc.y - player.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if(dist < DIALOGUE_RANGE && dist < minDist) {
      minDist = dist;
      closest = npc;
    }
  });

  return closest;
}

function showContacts() {
  document.getElementById('phoneMenu').style.display = 'none';
  document.getElementById('phoneContacts').style.display = 'flex';
}

function toggleFullMap() {
  const fullMap = document.getElementById('fullMap');
  fullMap.style.display = fullMap.style.display === 'none' ? 'block' : 'none';
  if(fullMap.style.display === 'block') {
    drawFullMap();
  }
}

function drawFullMap() {
  const fullCanvas = document.getElementById('fullMapCanvas');
  fullCanvas.width = window.innerWidth;
  fullCanvas.height = window.innerHeight;
  const ctx = fullCanvas.getContext('2d');
  
  // Draw the full map content
  ctx.fillStyle = 'rgba(0,0,0,0.9)';
  ctx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);
  
  // Draw player position
  ctx.fillStyle = '#ff0000';
  ctx.beginPath();
  ctx.arc(player.x / mapWidth * fullCanvas.width, 
          player.y / mapHeight * fullCanvas.height, 
          5, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw NPCs
  npcs.forEach(npc => {
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(npc.x / mapWidth * fullCanvas.width,
            npc.y / mapHeight * fullCanvas.height,
            3, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Generate the map
function generateMap() {
  const mapData = [];
  const centerX = mapWidth / 2;
  const centerY = mapHeight / 2;
  
  // Find nearest road tile to center
  let closestTile = { x: centerX, y: centerY };
  let minDistance = Infinity;
  for (let y = 0; y < mapHeight / tileSize; y+=0.25) {
    const row = [];
    for (let x = 0; x < mapWidth / tileSize; x+=0.25) {
      const noiseValue1 = simplex.noise2D(x * noiseScale, y * noiseScale);
      const noiseValue2 = simplex.noise2D(x * noiseScale2, y * noiseScale2) * 0.5;
      const combinedNoise = noiseValue1 + noiseValue2;

      let biome = 'grassland';
      if (combinedNoise < -0.5) {
        biome = 'water';
      } else if (combinedNoise < -0.1) {
        biome = 'suburbs';
      } else if (combinedNoise > 0.9) {
        biome = 'city';
      } else if (combinedNoise > 0.4) {
        biome = 'suburbs';
      }

      let tile = new Tile(biome);
      
      if (biome === 'suburbs' && !isSuburbRoad && Math.random() < HOUSE_PROBABILITY) {
        tile.hasHouse = true;
      }
      
      row.push(tile);
    }
    mapData.push(row);
  }


  for (let y = 0; y < mapData.length; y++) {
    for (let x = 0; x < mapData[y].length; x++) {
      if (mapData[y][x].biome === 'city' && isCityRoad(x, y)) {
        const tileX = x * tileSize;
        const tileY = y * tileSize;
        const dist = Math.hypot(tileX - centerX, tileY - centerY);
        
        if (dist < minDistance) {
          minDistance = dist;
          closestTile = { x: tileX, y: tileY };
        }
      }
    }
  }

  player.x = closestTile.x;
  player.y = closestTile.y;
  return mapData;
}

function determineHouseRotation(x, y) {
  if(y % 3 === 1) return Math.PI;
  else  return 0;
}
  
function getCurrentChunks() {
  const chunks = [];
  const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
  const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
  
  // Load 3x3 area around player
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      chunks.push(`${playerChunkX + x},${playerChunkY + y}`);
    }
  }
  return chunks;
}

function generateTraffic() {
  // Remove the player spawn code from here
  setInterval(() => {
    if (traffic.length < 20) {
      const spawnPoints = [];
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          const tile = map[y][x];
          const isRoad = tile.biome === 'city' ? 
            isCityRoad(x, y) : 
            tile.biome === 'suburbs' ? 
            isSuburbRoad(x, y) : 
            false;
          
          if (isRoad) {
            spawnPoints.push({
              x: x * tileSize + tileSize/2,
              y: y * tileSize + tileSize/2
            });
          }
        }
      }
      
      if (spawnPoints.length > 0) {
        const {x, y} = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
        traffic.push(new Car(x, y, 'traffic', colors[Math.floor(Math.random() * colors.length)]));
      }
    }
  }, 3000);
}

async function selectOption(index) {
  const optionText = document.querySelectorAll('.dialogue-option')[index].innerText;
  const response = await currentInteractingNPC.generateDialogue(optionText);
  
  const content = document.getElementById('dialogueContent');
  content.innerHTML = `
    <p><strong>You:</strong> ${optionText}</p>
    <p><strong>${currentInteractingNPC.name}:</strong> ${response.text}</p>
    ${response.options.map((opt, i) => `
      <div class="dialogue-option" onclick="selectOption(${i})">${opt}</div>
    `).join('')}
  `;

  currentInteractingNPC.conversationHistory.push(optionText);
  currentInteractingNPC.conversationHistory.push(response.text);
  
  if(response.options.length === 0) {
    endDialogue();
  }
}

function endDialogue() {
  document.getElementById('dialogueBox').style.display = 'none';
  currentInteractingNPC.interactionCooldown = 300;
  currentInteractingNPC = null;
  document.removeEventListener('keydown', handleDialogueKey);
}

function handleDialogueKey(e) {
  if(e.code === 'Escape') endDialogue();
}

function toggleMenu() {
  const menu = document.getElementById('phoneMenu');
  menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

function manageTraffic() {
  const currentChunks = getCurrentChunks();
  
  // Remove old chunks
  traffic.forEach((car, index) => {
    const carChunkX = Math.floor(car.x / CHUNK_SIZE);
    const carChunkY = Math.floor(car.y / CHUNK_SIZE);
    if (!currentChunks.includes(`${carChunkX},${carChunkY}`)) {
      traffic.splice(index, 1);
    }
  });

  // Add new chunks
  currentChunks.forEach(chunk => {
    if (!loadedChunks.has(chunk)) {
      loadedChunks.add(chunk);
      const [chunkX, chunkY] = chunk.split(',').map(Number);
      spawnTrafficInChunk(chunkX, chunkY);
    }
  });
}
function spawnTrafficInChunk(chunkX, chunkY) {
  const numCars = Math.floor(Math.random() * 3);
  for (let i = 0; i < numCars; i++) {
    const x = chunkX * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
    const y = chunkY * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
    const newCar = new Car(x, y, 'traffic', colors[Math.floor(Math.random() * colors.length)]);
    newCar.isTraffic = true;
    newCar.direction = [DIRECTION.UP, DIRECTION.RIGHT, DIRECTION.DOWN, DIRECTION.LEFT][
      Math.floor(Math.random() * 4)
    ];
    traffic.push(newCar);
  }
}
  
function spawnCar(type) {
  const colors = {
    sedan: '#666666',
    sports: '#FF3300',
    truck: '#00AAFF'
  };
  const newCar = new Car(player.x, player.y, type, colors[type]);
  newCar.enter(player);
  cars.push(newCar);
  toggleMenu();
}

function initializeNPCs() {
  // Add core NPCs
  CORE_NPCS.forEach(data => npcs.push(new NPC(data)));

  // Add faction NPCs around player
  const spawnRadius = 2000;
  for(let i = 0; i < 18; i++) {
    const template = NPC_TEMPLATES[i % NPC_TEMPLATES.length];
    npcs.push(new NPC({
      ...template,
      x: player.x + (Math.random() - 0.5) * spawnRadius,
      y: player.y + (Math.random() - 0.5) * spawnRadius
    }));
  }
}

function startConversation(npc) {
  chatSystem.startChat(npc);
}


function displayMessage(speaker, text) {
  const content = document.getElementById('dialogueContent');
  content.innerHTML += `<p><strong>${speaker}:</strong> ${text}</p>`;
  content.scrollTop = content.scrollHeight; // Auto-scroll
}

async function sendPlayerMessage() {
  const input = document.getElementById('playerInput');
  const message = input.value.trim();
  
  if(message) {
    displayMessage("You", message);
    const response = await currentInteractingNPC.generateResponse(message);
    displayMessage(currentInteractingNPC.name, response);
    input.value = '';
  }
}

function endConversation() {
  // Hide UI
  document.getElementById('dialogueBox').style.display = 'none';
  
  // Process world updates
  currentInteractingNPC.generateWorldUpdate()
    .then(update => applyWorldChanges(update));
  
  currentInteractingNPC = null;
}

function sendPlayerMessage() {
  const input = document.getElementById('playerInput').value;
  conversationManager.sendMessage(input);
}

function generateSidewalkNodes(tile) {
  const nodes = [];
  // Generate nodes along road edges
  if(tile.isCityRoad || tile.isSuburbRoad) {
    for(let i = 0; i < tileSize; i += 50) {
      nodes.push({ x: tile.x + i, y: tile.y });
      nodes.push({ x: tile.x + i, y: tile.y + tileSize });
      nodes.push({ x: tile.x, y: tile.y + i });
      nodes.push({ x: tile.x + tileSize, y: tile.y + i });
    }
  }
  return nodes;
}
// Road logic
function isCityRoad(x, y) {
  const cycle = 6;
  const xMod = x % cycle;
  const yMod = y % cycle;
  return (xMod === 0) || (yMod === 0);
}

function isSuburbRoad(x, y) {
  const mainCycle = 15;
  const branchCycle = 3;
  return (x % mainCycle === 0) || (y % branchCycle === 0);
}
  
function isRoadTile(x, y) {
  if (x < 0 || y < 0 || x >= map[0].length || y >= map.length) return false;
  const tile = map[y][x];
  return (tile.biome === 'city' && isCityRoad(x, y)) || 
         (tile.biome === 'suburbs' && isSuburbRoad(x, y));
}

function getRoadRotation(x, y) {
  const neighbors = {
    left: isRoadTile(x - 1, y),
    right: isRoadTile(x + 1, y),
    up: isRoadTile(x, y - 1),
    down: isRoadTile(x, y + 1)
  };
  const count = Object.values(neighbors).filter(v => v).length;

  // Determine road type and rotation
  if (count === 4) return { type: 'x', rotation: 0 };
  if (count === 3) { // T-intersection
    if (!neighbors.up) return { type: 't', rotation: 0 };
    if (!neighbors.down) return { type: 't', rotation: Math.PI };
    if (!neighbors.left) return { type: 't', rotation: -Math.PI/2 };
    return { type: 't', rotation: Math.PI/2 };
  }
  if (count === 2) {
    if (neighbors.left && neighbors.right) return { type: 'straight', rotation: 0 };
    if (neighbors.up && neighbors.down) return { type: 'straight', rotation: Math.PI/2 };
    if (neighbors.right && neighbors.down) return { type: 'turn', rotation: 0 };
    if (neighbors.down && neighbors.left) return { type: 'turn', rotation: Math.PI/2 };
    if (neighbors.left && neighbors.up) return { type: 'turn', rotation: Math.PI };
    if (neighbors.up && neighbors.right) return { type: 'turn', rotation: -Math.PI/2 };
  }
  if (count === 1) { // Dead end
    if (neighbors.left) return { type: 'dead_end', rotation: Math.PI };
    if (neighbors.right) return { type: 'dead_end', rotation: 0 };
    if (neighbors.up) return { type: 'dead_end', rotation: -Math.PI/2 };
    return { type: 'dead_end', rotation: Math.PI/2 };
  }
  return { type: 'straight', rotation: Math.PI / 2 }; // Default
}


// Draw the map
function drawMap() {
  const viewWidth = Math.ceil(canvas.width / tileSize);
  const viewHeight = Math.ceil(canvas.height / tileSize);
  const offsetX = player.x - canvas.width / 2;
  const offsetY = player.y - canvas.height / 2;
  const startTileX = Math.floor(offsetX / tileSize);
  const startTileY = Math.floor(offsetY / tileSize);
  const tileOffsetX = offsetX % tileSize;
  const tileOffsetY = offsetY % tileSize;

  // First pass: Draw base terrain
  for (let y = 0; y <= viewHeight; y++) {
    for (let x = 0; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < mapWidth / tileSize && mapY >= 0 && mapY < mapHeight / tileSize) {
        const tile = map[mapY][mapX];
        const texture = textures.grassland


        
        // Only draw base texture here
        ctx.drawImage(
          texture,
          x * tileSize - tileOffsetX,
          y * tileSize - tileOffsetY,
          tileSize,
          tileSize
        );
      }
    }
  }

  // Second pass: Draw roads and houses
  for (let y = 0; y <= viewHeight; y++) {
    for (let x = 0; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < mapWidth / tileSize && mapY >= 0 && mapY < mapHeight / tileSize) {
        const tile = map[mapY][mapX];
        const worldTileX = mapX;
        const worldTileY = mapY;

        // Draw roads
        const isCityR = tile.biome === 'city' && isCityRoad(mapX, mapY);
        const isSuburbR = tile.biome === 'suburbs' && isSuburbRoad(mapX, mapY);
      

        if (isCityR || isSuburbR) {
          const posX = x * tileSize - tileOffsetX;
          const posY = y * tileSize - tileOffsetY;
          const roadInfo = getRoadRotation(mapX, mapY);

          ctx.save();
          ctx.translate(posX + tileSize/2, posY + tileSize/2);
          ctx.rotate(roadInfo.rotation);
          ctx.drawImage(
            textures[`road_${roadInfo.type}`],
            -tileSize/2,
            -tileSize/2,
            tileSize,
            tileSize
          );
          ctx.restore();
        }

        // Draw houses
        if (tile.hasHouse || (!(isCityR || isSuburbR) && tile.biome === 'suburbs')) {
          ctx.save();
          const posX = x * tileSize - tileOffsetX;
          const posY = y * tileSize - tileOffsetY;
          
          // Determine house rotation based on nearest road
          const rotation = determineHouseRotation(mapX, mapY);
          ctx.translate(posX + tileSize/2, posY + tileSize/2);
          ctx.rotate(rotation);
          ctx.drawImage(
            textures.house,
            -tileSize/2,
            -tileSize/2,
            tileSize,
            tileSize
          );
          ctx.restore();
        }
        if( tile.biome === 'water'){
          ctx.save();
          const posX = x * tileSize - tileOffsetX;
          const posY = y * tileSize - tileOffsetY;
          
          // Determine house rotation based on nearest road
          ctx.translate(posX + tileSize/2, posY + tileSize/2);
          ctx.drawImage(
            textures.water,
            -tileSize/2,
            -tileSize/2,
            tileSize,
            tileSize
          );
          ctx.restore();
        }
      }
    }
  }
}

// Game loop
function gameLoop() {

  // Keep player within bounds
    // Player/Car movement
   if (player.currentVehicle) {
    player.currentVehicle.update();
    player.x = player.currentVehicle.x;
    player.y = player.currentVehicle.y;
  } else {
    if (keys.ArrowUp || keys.KeyW) player.y -= player.speed;
    if (keys.ArrowDown || keys.KeyS) player.y += player.speed;
    if (keys.ArrowLeft || keys.KeyA) player.x -= player.speed;
    if (keys.ArrowRight || keys.KeyD) player.x += player.speed;
    
    // Check for nearby cars to enter
    const enterRange = 50;
    const nearbyCar = [...cars, ...traffic].find(car => 
      !car.driver &&
      Math.abs(car.x - player.x) < enterRange &&
      Math.abs(car.y - player.y) < enterRange
    );
    
    //if (keys.KeyF && nearbyCar) {
    //  nearbyCar.enter(player);
    //}
  }

  // Exit vehicle
  //if (keys.KeyE && player.currentVehicle) {
  //  player.currentVehicle.exit();
  //}

  // Keep within bounds
  player.x = Math.max(0, Math.min(mapWidth - tileSize, player.x));
  player.y = Math.max(0, Math.min(mapHeight - tileSize, player.y));

  // Manage traffic chunks
  manageTraffic();
  //checkCurrentCity();

  // Update entities
  traffic.forEach(car => car.update());
  cars.forEach(car => car.update());

  // Draw everything
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();

  // Draw cars
  traffic.forEach(car => car.draw(ctx, player.x, player.y));
  cars.forEach(car => car.draw(ctx, player.x, player.y));
  npcs.forEach(npc => {
    if(!npc.isInConversation) npc.update();
    if(Date.now() - npc.lastAIUpdate > NPC_UPDATE_INTERVAL) npc.updateBehavior();
  });
  

  // Draw NPCs
  npcs.forEach(npc => npc.draw(ctx, player.x, player.y));
  mapSystem.draw();

  // Draw player if visible
  if (player.visible) {
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(
      canvas.width/2 - playerSize/2,
      canvas.height/2 - playerSize/2,
      playerSize,
      playerSize
    );
  }

  requestAnimationFrame(gameLoop);
}

// Start the game loop after textures load
player.visible = true;
player.currentVehicle = null;
const map = generateMap();
const chatSystem = new ChatSystem();
const mapSystem = new MapSystem();
initializeNPCs()
generateTraffic();
const allTextures = Object.values(textures);
Promise.all(allTextures.map((img) => new Promise((resolve) => (img.onload = resolve)))).then(() => {
  gameLoop();
});
</script>
</body>
</html>
