<!DOCTYPE html>
<html>
<head>
  <title>UoE3 Game</title>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #phoneMenu {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      height: 500px;
      background: rgba(0,0,0,0.8);
      color: white;
      display: none;
      padding: 20px;
      border-radius: 10px;
    }
    .menu-item { 
      padding: 10px; 
      margin: 5px;
      background: #333;
      cursor: pointer;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
  
<div id="phoneMenu">
  <h3>Phone</h3>
  <div class="menu-item" onclick="spawnCar('sedan')">Spawn Sedan</div>
  <div class="menu-item" onclick="spawnCar('sports')">Spawn Sports Car</div>
  <div class="menu-item" onclick="spawnCar('truck')">Spawn Truck</div>
</div>

<script type="module">
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mapWidth = 300000;
const mapHeight = 300000;
const tileSize = 400; // Adjusted for zoom
const playerSize = 16;
const noiseScale = 0.02;
const noiseScale2 = 0.05;
const DIRECTION = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
const cars = [];
const traffic = [];
const HOUSE_PROBABILITY = 0.3;
const CHUNK_SIZE = 1000; // World units
const loadedChunks = new Set();
const npcs = [];
let currentInteractingNPC = null;
const NPC_UPDATE_INTERVAL = 5000; // Update NPC behavior every 5 seconds
const DIALOGUE_RANGE = 100; // Distance for conversation
import { API_KEY } from "./config.js";
console.log("API Key:", API_KEY);

  
const storyState = {
  cityMood: "calm",
  recentEvents: [],
  playerReputation: 0
};
  
canvas.width = 1920; // Fixed viewport size
canvas.height = 1080;

const simplex = new SimplexNoise();

const player = {
  x: 100,
  y: 100,
  speed: 2,
  visible: true,
  currentVehicle: null
};

const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
};

document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
});

document.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});
document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyF') keys.KeyF = true;
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'KeyF') keys.KeyF = false;
});
document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyM') keys.KeyM = true;
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'KeyM') keys.KeyM = false;
});

// Textures
const textures = {
  water: new Image(),
  city: new Image(),
  suburbs: new Image(),
  grassland: new Image(),
  road_straight: new Image(),
  road_turn: new Image(),
  road_t: new Image(),
  road_x: new Image(),
  road_dead_end: new Image(),
  house: new Image(),
  driveway: new Image()
};

// Load textures
textures.water.src = 'water.png';
textures.city.src = 'city.png';
textures.suburbs.src = 'suburbs.png';
textures.grassland.src = 'grassland.png';
textures.road_straight.src = 'road_straight.png';
textures.road_turn.src = 'road_turn.png';
textures.road_t.src = 'road_t.png';
textures.road_x.src = 'road_x.png';
textures.road_dead_end.src = 'road_dead_end.png';
textures.house.src = 'house.png';
textures.driveway.src = 'driveway.png';

class Tile {
  constructor(biome, hasHouse = false, driveway = null) {
    this.biome = biome;
    this.hasHouse = hasHouse;
    this.driveway = driveway;
  }
}
  
class NPC {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.name = this.generateName();
    this.personality = this.generatePersonality();
    this.currentAction = "wandering";
    this.destination = this.getRandomDestination();
    this.conversationHistory = [];
    this.lastAIUpdate = 0;
    this.speed = 0.5;
    this.interactionCooldown = 0;
  }

  generateName() {
    const names = ["Alex", "Sam", "Jordan", "Taylor", "Casey"];
    return names[Math.floor(Math.random() * names.length)];
  }

  generatePersonality() {
    const traits = {
      openness: Math.random(),
      conscientiousness: Math.random(),
      extraversion: Math.random(),
      agreeableness: Math.random(),
      neuroticism: Math.random()
    };
    return traits;
  }

  async updateBehavior() {
    if (Date.now() - this.lastAIUpdate > NPC_UPDATE_INTERVAL) {
      try {
        const prompt = `In a city that's currently ${storyState.cityMood}, ${this.name}, who is ${this.describePersonality()}, is currently ${this.currentAction}. Recent events: ${storyState.recentEvents.join(", ")}. What should they do next? Respond with ONLY a JSON object containing: {action: "string", destination: {x: number, y: number}, mood: "string"}`;
        
        const response = await this.queryOpenAI(prompt);
        const behavior = JSON.parse(response);
        
        this.currentAction = behavior.action;
        this.destination = behavior.destination;
        this.lastAIUpdate = Date.now();
        
        if(behavior.mood) {
          this.mood = behavior.mood;
        }
      } catch (error) {
        console.error("AI behavior error:", error);
      }
    }
  }

  describePersonality() {
    return `openness ${this.personality.openness.toFixed(2)}, conscientiousness ${this.personality.conscientiousness.toFixed(2)}, extraversion ${this.personality.extraversion.toFixed(2)}, agreeableness ${this.personality.agreeableness.toFixed(2)}, neuroticism ${this.personality.neuroticism.toFixed(2)}`;
  }

  async queryOpenAI(prompt) {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [{
          role: "user",
          content: prompt
        }],
        temperature: 0.7,
        max_tokens: 150
      })
    });

    const data = await response.json();
    return data.choices[0].message.content.trim();
  }

  update() {
    // Movement towards destination
    const dx = this.destination.x - this.x;
    const dy = this.destination.y - this.y;
    const distance = Math.sqrt(dx*dx + dy*dy);

    if(distance > 10) {
      this.x += (dx/distance) * this.speed;
      this.y += (dy/distance) * this.speed;
    } else {
      this.destination = this.getRandomDestination();
    }

    if(this.interactionCooldown > 0) this.interactionCooldown--;
  }

  getRandomDestination() {
    return {
      x: this.x + (Math.random() - 0.5) * 500,
      y: this.y + (Math.random() - 0.5) * 500
    };
  }

  async generateDialogue(playerInput = null) {
    try {
      const prompt = this.createDialoguePrompt(playerInput);
      const response = await this.queryOpenAI(prompt);
      return this.processAIResponse(response);
    } catch (error) {
      console.error("Dialogue error:", error);
      return {text: "I can't talk right now.", options: []};
    }
  }

  createDialoguePrompt(playerInput) {
    return `In a ${storyState.cityMood} city, ${this.name} (${this.describePersonality()}) is talking to a player with reputation ${storyState.playerReputation}. 
    Previous conversation: ${this.conversationHistory.slice(-3).join(" | ")}
    ${playerInput ? `Player says: "${playerInput}"` : "Player initiates conversation"}
    Generate natural dialogue response and up to 3 options. Respond ONLY with JSON: {text: "string", options: ["string"], storyEffects: {}}`;
  }

  processAIResponse(response) {
    try {
      const data = JSON.parse(response);
      if(data.storyEffects) {
        Object.assign(storyState, data.storyEffects);
        if(data.storyEffects.recentEvents) {
          storyState.recentEvents.push(data.storyEffects.recentEvents);
          if(storyState.recentEvents.length > 5) storyState.recentEvents.shift();
        }
      }
      return data;
    } catch {
      return {text: response, options: []};
    }
  }

  draw(ctx, playerX, playerY) {
    const screenX = this.x - playerX + canvas.width/2;
    const screenY = this.y - playerY + canvas.height/2;
    
    // Draw NPC
    ctx.fillStyle = '#00FF00';
    ctx.beginPath();
    ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw name
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(this.name, screenX, screenY - 12);
  }
}

class Car {
  constructor(x, y, type, color) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.color = color;

    // Vehicle performance characteristics
    switch(type) {
      case 'sports':
        this.maxSpeed = 4;
        this.acceleration = 0.01;
        this.minTurningRadius = 5;
        this.grip = 1.2;
        this.steeringResponse = 0.04;
        break;
      case 'truck':
        this.maxSpeed = 2;
        this.acceleration = 0.005;
        this.minTurningRadius = 7;
        this.grip = 2.0;
        this.steeringResponse = 0.04;
        break;
      default: // sedan
        this.maxSpeed = 3;
        this.acceleration = 0.0075;
        this.minTurningRadius = 6;
        this.grip = 1.6;
        this.steeringResponse = 0.03;
    }

    this.angle = 0;
    this.width = 30;
    this.height = 15;
    this.driver = null;
    this.active = false;
    this.isTraffic = false;
    this.currentSpeed = 0;
    this.deceleration = 0.002;
    this.wheelBase = 20; // Distance between front and rear axles
    this.track = this.width * 0.6; // Distance between left/right wheels
  }

  enter(player) {
    this.driver = player;
    this.active = true;
    player.visible = false;
    player.currentVehicle = this;
    this.currentSpeed = 0;
    this.x = player.x;
    this.y = player.y;
  }

  exit() {
    if (this.driver) {
      this.driver.x = this.x;
      this.driver.y = this.y;
      this.driver.visible = true;
      this.driver.currentVehicle = null;
      this.driver = null;
    }
    this.active = false;
  }

  draw(ctx, playerX, playerY) {
    const screenX = this.x - playerX + canvas.width/2 - this.width/2;
    const screenY = this.y - playerY + canvas.height/2 - this.height/2;
    
    ctx.save();
    ctx.translate(screenX + this.width/2, screenY + this.height/2);
    ctx.rotate(this.angle);
    ctx.fillStyle = this.color;
    
    // Draw car body
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    
    // Draw wheels
    ctx.fillStyle = '#333';
    const wheelWidth = 8;
    const wheelHeight = 4;
    const axleFront = this.wheelBase/2;
    const axleRear = -this.wheelBase/2;
    
    // Front wheels
    ctx.fillRect(-this.track/2, axleFront - wheelHeight/2, wheelWidth, wheelHeight);
    ctx.fillRect(this.track/2 - wheelWidth, axleFront - wheelHeight/2, wheelWidth, wheelHeight);
    
    // Rear wheels
    ctx.fillRect(-this.track/2, axleRear - wheelHeight/2, wheelWidth, wheelHeight);
    ctx.fillRect(this.track/2 - wheelWidth, axleRear - wheelHeight/2, wheelWidth, wheelHeight);
    
    ctx.restore();
  }

  update() {
    if (this.active && this.driver) {
      // Steering physics
      let steeringInput = 0;
      if (keys.KeyA) steeringInput -= 1;
      if (keys.KeyD) steeringInput += 1;

      if (steeringInput !== 0 && this.currentSpeed !== 0) {
        const speed = Math.abs(this.currentSpeed);
        const maxTheoreticalSpeed = Math.sqrt(this.grip * this.minTurningRadius);
        let effectiveRadius;

        if (speed <= maxTheoreticalSpeed) {
          effectiveRadius = this.minTurningRadius;
        } else {
          effectiveRadius = (speed ** 2) / this.grip;
        }

        // Improved speed-sensitive steering
        const baseAngularVelocity = (this.currentSpeed / effectiveRadius) * steeringInput;
        const speedFactor = Math.min(1, speed / this.maxSpeed);
        const adjustedAngular = baseAngularVelocity * (1 - speedFactor * 0.7);
        
        this.angle += adjustedAngular * this.steeringResponse;
      }

      // Acceleration physics
      if (keys.KeyW) {
        this.currentSpeed = Math.min(
          this.currentSpeed + this.acceleration,
          this.maxSpeed
        );
      } else if (keys.KeyS) {
        this.currentSpeed = Math.max(
          this.currentSpeed - this.acceleration * 2,
          -this.maxSpeed * 0.5
        );
      } else {
        // Natural deceleration with rolling resistance
        const decel = this.currentSpeed > 0 ? 
          -this.deceleration * (1 + this.currentSpeed/this.maxSpeed) : 
          this.deceleration * (1 - this.currentSpeed/this.maxSpeed);
        this.currentSpeed += decel;
        if (Math.abs(this.currentSpeed) < 0.1) this.currentSpeed = 0;
      }
      
      // Apply movement with momentum
      const moveAngle = this.angle;
      this.x += Math.cos(moveAngle) * this.currentSpeed;
      this.y += Math.sin(moveAngle) * this.currentSpeed;
    } else if (this.isTraffic) {
      // Simplified traffic movement with basic physics
      this.currentSpeed = Math.min(
        this.currentSpeed + this.acceleration * 0.5,
        this.maxSpeed * 0.8
      );
      
      // Gentle traffic steering
      if (Math.random() < 0.01) {
        const maxTurnSpeed = Math.sqrt(this.grip * this.minTurningRadius);
        const speedFactor = Math.min(1, this.currentSpeed / maxTurnSpeed);
        this.angle += (Math.random() - 0.5) * this.steeringResponse * (1 - speedFactor);
      }
      
      this.x += Math.cos(this.angle) * this.currentSpeed;
      this.y += Math.sin(this.angle) * this.currentSpeed;
    }
  }
}
  
// Generate the map
function generateMap() {
  const mapData = [];
  const centerX = mapWidth / 2;
  const centerY = mapHeight / 2;
  
  // Find nearest road tile to center
  let closestTile = { x: centerX, y: centerY };
  let minDistance = Infinity;
  for (let y = 0; y < mapHeight / tileSize; y+=0.25) {
    const row = [];
    for (let x = 0; x < mapWidth / tileSize; x+=0.25) {
      const noiseValue1 = simplex.noise2D(x * noiseScale, y * noiseScale);
      const noiseValue2 = simplex.noise2D(x * noiseScale2, y * noiseScale2) * 0.5;
      const combinedNoise = noiseValue1 + noiseValue2;

      let biome = 'grassland';
      if (combinedNoise < -0.5) {
        biome = 'water';
      } else if (combinedNoise < -0.1) {
        biome = 'suburbs';
      } else if (combinedNoise > 0.9) {
        biome = 'city';
      } else if (combinedNoise > 0.4) {
        biome = 'suburbs';
      }

      let tile = new Tile(biome);
      
      if (biome === 'suburbs' && !isSuburbRoad && Math.random() < HOUSE_PROBABILITY) {
        tile.hasHouse = true;
      }
      
      row.push(tile);
    }
    mapData.push(row);
  }


  for (let y = 0; y < mapData.length; y++) {
    for (let x = 0; x < mapData[y].length; x++) {
      if (mapData[y][x].biome === 'city' && isCityRoad(x, y)) {
        const tileX = x * tileSize;
        const tileY = y * tileSize;
        const dist = Math.hypot(tileX - centerX, tileY - centerY);
        
        if (dist < minDistance) {
          minDistance = dist;
          closestTile = { x: tileX, y: tileY };
        }
      }
    }
  }

  player.x = closestTile.x;
  player.y = closestTile.y;
  return mapData;
}

function determineHouseRotation(x, y) {
  if(y % 3 === 1) return Math.PI;
  else  return 0;
}
  
function getCurrentChunks() {
  const chunks = [];
  const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
  const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
  
  // Load 3x3 area around player
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      chunks.push(`${playerChunkX + x},${playerChunkY + y}`);
    }
  }
  return chunks;
}

function generateTraffic() {
  // Remove the player spawn code from here
  setInterval(() => {
    if (traffic.length < 20) {
      const spawnPoints = [];
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          const tile = map[y][x];
          const isRoad = tile.biome === 'city' ? 
            isCityRoad(x, y) : 
            tile.biome === 'suburbs' ? 
            isSuburbRoad(x, y) : 
            false;
          
          if (isRoad) {
            spawnPoints.push({
              x: x * tileSize + tileSize/2,
              y: y * tileSize + tileSize/2
            });
          }
        }
      }
      
      if (spawnPoints.length > 0) {
        const {x, y} = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
        traffic.push(new Car(x, y, 'traffic', colors[Math.floor(Math.random() * colors.length)]));
      }
    }
  }, 3000);
}
async function selectOption(index) {
  const optionText = document.querySelectorAll('.dialogue-option')[index].innerText;
  const response = await currentInteractingNPC.generateDialogue(optionText);
  
  const content = document.getElementById('dialogueContent');
  content.innerHTML = `
    <p><strong>You:</strong> ${optionText}</p>
    <p><strong>${currentInteractingNPC.name}:</strong> ${response.text}</p>
    ${response.options.map((opt, i) => `
      <div class="dialogue-option" onclick="selectOption(${i})">${opt}</div>
    `).join('')}
  `;

  currentInteractingNPC.conversationHistory.push(optionText);
  currentInteractingNPC.conversationHistory.push(response.text);
  
  if(response.options.length === 0) {
    endDialogue();
  }
}

function endDialogue() {
  document.getElementById('dialogueBox').style.display = 'none';
  currentInteractingNPC.interactionCooldown = 300;
  currentInteractingNPC = null;
  document.removeEventListener('keydown', handleDialogueKey);
}

function handleDialogueKey(e) {
  if(e.code === 'Escape') endDialogue();
}

function toggleMenu() {
  const menu = document.getElementById('phoneMenu');
  menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

function manageTraffic() {
  const currentChunks = getCurrentChunks();
  
  // Remove old chunks
  traffic.forEach((car, index) => {
    const carChunkX = Math.floor(car.x / CHUNK_SIZE);
    const carChunkY = Math.floor(car.y / CHUNK_SIZE);
    if (!currentChunks.includes(`${carChunkX},${carChunkY}`)) {
      traffic.splice(index, 1);
    }
  });

  // Add new chunks
  currentChunks.forEach(chunk => {
    if (!loadedChunks.has(chunk)) {
      loadedChunks.add(chunk);
      const [chunkX, chunkY] = chunk.split(',').map(Number);
      spawnTrafficInChunk(chunkX, chunkY);
    }
  });
}
function spawnTrafficInChunk(chunkX, chunkY) {
  const numCars = Math.floor(Math.random() * 3);
  for (let i = 0; i < numCars; i++) {
    const x = chunkX * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
    const y = chunkY * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
    const newCar = new Car(x, y, 'traffic', colors[Math.floor(Math.random() * colors.length)]);
    newCar.isTraffic = true;
    newCar.direction = [DIRECTION.UP, DIRECTION.RIGHT, DIRECTION.DOWN, DIRECTION.LEFT][
      Math.floor(Math.random() * 4)
    ];
    traffic.push(newCar);
  }
}
  
function spawnCar(type) {
  const colors = {
    sedan: '#666666',
    sports: '#FF3300',
    truck: '#00AAFF'
  };
  const newCar = new Car(player.x, player.y, type, colors[type]);
  newCar.enter(player);
  cars.push(newCar);
  toggleMenu();
}

function initializeNPCs() {
  for(let i = 0; i < 20; i++) {
    npcs.push(new NPC(
      Math.random() * mapWidth,
      Math.random() * mapHeight
    ));
  }
}
// Road logic
function isCityRoad(x, y) {
  const cycle = 6;
  const xMod = x % cycle;
  const yMod = y % cycle;
  return (xMod === 0) || (yMod === 0);
}

function isSuburbRoad(x, y) {
  const mainCycle = 15;
  const branchCycle = 3;
  return (x % mainCycle === 0) || (y % branchCycle === 0);
}
  
function isRoadTile(x, y) {
  if (x < 0 || y < 0 || x >= map[0].length || y >= map.length) return false;
  const tile = map[y][x];
  return (tile.biome === 'city' && isCityRoad(x, y)) || 
         (tile.biome === 'suburbs' && isSuburbRoad(x, y));
}

function getRoadRotation(x, y) {
  const neighbors = {
    left: isRoadTile(x - 1, y),
    right: isRoadTile(x + 1, y),
    up: isRoadTile(x, y - 1),
    down: isRoadTile(x, y + 1)
  };
  const count = Object.values(neighbors).filter(v => v).length;

  // Determine road type and rotation
  if (count === 4) return { type: 'x', rotation: 0 };
  if (count === 3) { // T-intersection
    if (!neighbors.up) return { type: 't', rotation: 0 };
    if (!neighbors.down) return { type: 't', rotation: Math.PI };
    if (!neighbors.left) return { type: 't', rotation: -Math.PI/2 };
    return { type: 't', rotation: Math.PI/2 };
  }
  if (count === 2) {
    if (neighbors.left && neighbors.right) return { type: 'straight', rotation: 0 };
    if (neighbors.up && neighbors.down) return { type: 'straight', rotation: Math.PI/2 };
    if (neighbors.right && neighbors.down) return { type: 'turn', rotation: 0 };
    if (neighbors.down && neighbors.left) return { type: 'turn', rotation: Math.PI/2 };
    if (neighbors.left && neighbors.up) return { type: 'turn', rotation: Math.PI };
    if (neighbors.up && neighbors.right) return { type: 'turn', rotation: -Math.PI/2 };
  }
  if (count === 1) { // Dead end
    if (neighbors.left) return { type: 'dead_end', rotation: Math.PI };
    if (neighbors.right) return { type: 'dead_end', rotation: 0 };
    if (neighbors.up) return { type: 'dead_end', rotation: -Math.PI/2 };
    return { type: 'dead_end', rotation: Math.PI/2 };
  }
  return { type: 'straight', rotation: Math.PI / 2 }; // Default
}


// Draw the map
function drawMap() {
  const viewWidth = Math.ceil(canvas.width / tileSize);
  const viewHeight = Math.ceil(canvas.height / tileSize);
  const offsetX = player.x - canvas.width / 2;
  const offsetY = player.y - canvas.height / 2;
  const startTileX = Math.floor(offsetX / tileSize);
  const startTileY = Math.floor(offsetY / tileSize);
  const tileOffsetX = offsetX % tileSize;
  const tileOffsetY = offsetY % tileSize;

  // First pass: Draw base terrain
  for (let y = 0; y <= viewHeight; y++) {
    for (let x = 0; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < mapWidth / tileSize && mapY >= 0 && mapY < mapHeight / tileSize) {
        const tile = map[mapY][mapX];
        const texture = textures[tile.F] || textures.grassland;
        
        // Only draw base texture here
        ctx.drawImage(
          texture,
          x * tileSize - tileOffsetX,
          y * tileSize - tileOffsetY,
          tileSize,
          tileSize
        );
      }
    }
  }

  // Second pass: Draw roads and houses
  for (let y = 0; y <= viewHeight; y++) {
    for (let x = 0; x <= viewWidth; x++) {
      const mapX = startTileX + x;
      const mapY = startTileY + y;

      if (mapX >= 0 && mapX < mapWidth / tileSize && mapY >= 0 && mapY < mapHeight / tileSize) {
        const tile = map[mapY][mapX];
        const worldTileX = mapX;
        const worldTileY = mapY;

        // Draw roads
        const isCity = tile.biome === 'city' && isCityRoad(mapX, mapY);
        const isSuburb = tile.biome === 'suburbs' && isSuburbRoad(mapX, mapY);
        
        if (isCity || isSuburb) {
          const posX = x * tileSize - tileOffsetX;
          const posY = y * tileSize - tileOffsetY;
          const roadInfo = getRoadRotation(mapX, mapY);

          ctx.save();
          ctx.translate(posX + tileSize/2, posY + tileSize/2);
          ctx.rotate(roadInfo.rotation);
          ctx.drawImage(
            textures[`road_${roadInfo.type}`],
            -tileSize/2,
            -tileSize/2,
            tileSize,
            tileSize
          );
          ctx.restore();
        }

        // Draw houses
        if (tile.hasHouse || (!(isCity || isSuburb) && tile.biome === 'suburbs')) {
          ctx.save();
          const posX = x * tileSize - tileOffsetX;
          const posY = y * tileSize - tileOffsetY;
          
          // Determine house rotation based on nearest road
          const rotation = determineHouseRotation(mapX, mapY);
          ctx.translate(posX + tileSize/2, posY + tileSize/2);
          ctx.rotate(rotation);
          ctx.drawImage(
            textures.house,
            -tileSize/2,
            -tileSize/2,
            tileSize,
            tileSize
          );
          ctx.restore();
        }
      }
    }
  }
}

// Game loop
function gameLoop() {
  
  
  if (keys.KeyM) toggleMenu();


  // Keep player within bounds
    // Player/Car movement
   if (player.currentVehicle) {
    player.currentVehicle.update();
    player.x = player.currentVehicle.x;
    player.y = player.currentVehicle.y;
  } else {
    if (keys.ArrowUp) player.y -= player.speed;
    if (keys.ArrowDown) player.y += player.speed;
    if (keys.ArrowLeft) player.x -= player.speed;
    if (keys.ArrowRight) player.x += player.speed;
    
    // Check for nearby cars to enter
    const enterRange = 50;
    const nearbyCar = [...cars, ...traffic].find(car => 
      !car.driver &&
      Math.abs(car.x - player.x) < enterRange &&
      Math.abs(car.y - player.y) < enterRange
    );
    
    if (keys.KeyF && nearbyCar) {
      nearbyCar.enter(player);
    }
  }

  // Exit vehicle
  if (keys.KeyE && player.currentVehicle) {
    player.currentVehicle.exit();
  }

  // Keep within bounds
  player.x = Math.max(0, Math.min(mapWidth - tileSize, player.x));
  player.y = Math.max(0, Math.min(mapHeight - tileSize, player.y));

  // Manage traffic chunks
  manageTraffic();

  // Update entities
  traffic.forEach(car => car.update());
  cars.forEach(car => car.update());

  // Draw everything
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();

  // Draw cars
  traffic.forEach(car => car.draw(ctx, player.x, player.y));
  cars.forEach(car => car.draw(ctx, player.x, player.y));
  npcs.forEach(npc => {
    npc.update();
    if(Date.now() - npc.lastAIUpdate > NPC_UPDATE_INTERVAL) {
      npc.updateBehavior();
    }
  });
  
  if(!currentInteractingNPC && player.visible) {
    npcs.forEach(npc => {
      const distance = Math.hypot(npc.x - player.x, npc.y - player.y);
      if(distance < DIALOGUE_RANGE && npc.interactionCooldown === 0) {
        startDialogue(npc);
      }
    });
  }


  // Draw NPCs
  npcs.forEach(npc => npc.draw(ctx, player.x, player.y));
  // Draw player if visible
  if (player.visible) {
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(
      canvas.width/2 - playerSize/2,
      canvas.height/2 - playerSize/2,
      playerSize,
      playerSize
    );
  }

  requestAnimationFrame(gameLoop);
}

// Start the game loop after textures load
player.visible = true;
player.currentVehicle = null;
const map = generateMap();
generateTraffic();
const allTextures = Object.values(textures);
Promise.all(allTextures.map((img) => new Promise((resolve) => (img.onload = resolve)))).then(() => {
  gameLoop();
});
</script>
</body>
</html>
